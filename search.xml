<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MYSQL命令行</title>
      <link href="2021/06/25/MySQL/"/>
      <url>2021/06/25/MySQL/</url>
      
        <content type="html"><![CDATA[<h3 id="MYSQL安装和配置"><a href="#MYSQL安装和配置" class="headerlink" title="MYSQL安装和配置"></a>MYSQL安装和配置</h3><p><a href="https://dev.mysql.com/downloads/mysql/">MYSQL免安装版本</a></p><blockquote><p>解压到路径不带中文的目录下</p></blockquote><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210625135904756.png" alt="image-20210625135904756"></p><blockquote><p>设置环境变量</p></blockquote><p>将bin文件夹添加到环境变量中</p><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210625140311650.png" alt="image-20210625140311650"></p><blockquote><p>以管理员方式打开cmd或者powershell</p></blockquote><blockquote><p>输入mysqld命令</p></blockquote><blockquote><p>再输入mysqld –install mysql8.0，因为我的是mysql-8.0.25-winx64，所以是mysql8.0，需要根据你们情况修改</p></blockquote><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210625140844190.png" alt="image-20210625140844190"></p><blockquote><p>再输入net start mysql8.0</p></blockquote><blockquote><p>MYSQL初始化：mysqld –initialize –console，初始化会产生一个随机密码，需要记住</p></blockquote><blockquote><p>登录MYSQL：mysql -u root -p，输入刚刚随机产生的密码</p></blockquote><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210625160247880.png" alt="image-20210625160247880"></p><blockquote><p>修改密码：alter  user  ‘root’@’localhost’  identified by ‘root’; 然后root账户的密码就是root了</p></blockquote><h3 id="连接MYSQL数据库"><a href="#连接MYSQL数据库" class="headerlink" title="连接MYSQL数据库"></a>连接MYSQL数据库</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># mysql -h主机地址 -u用户名 -p密码mysql -u root -p # 回车输入密码# 刚开始安装后超级用户root没有密码，直接回车即可进入到MYSQL中# 退出MYSQL命令exit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="修改MYSQL数据库"><a href="#修改MYSQL数据库" class="headerlink" title="修改MYSQL数据库"></a>修改MYSQL数据库</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># mysqladmin -u用户名 -p旧密码 password 新密码mysqladmin -u root -password 123456 # 因为一开始root没有密码mysqladmin -u root -p 123456 password 654321# 也可以这样修改alter user &#39;root&#39;@&#39;localhost&#39; identified by &#39;123&#39;; # 修改密码为123<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="增加新用户并且修改权限"><a href="#增加新用户并且修改权限" class="headerlink" title="增加新用户并且修改权限"></a>增加新用户并且修改权限</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># grant 权限 on 数据库.* to 用户名@登录主机 identified by &quot;密码&quot;# 增加一个用户user1密码为password，让其可以在本机上登录， 并对所有数据库有查询、插入、修改、删除的权限。首先用以root用户连入mysql，然后键入以下命令:grant select,insert,update,delete on *.* to &quot;user1&quot;@&quot;localhost&quot; Identified by &quot;password&quot;;# 如果希望该用户能够在任何机器上登陆mysql，则将localhost改为&quot;%&quot;# 如果你不想user1有密码，可以再打一个命令将密码去掉grant select,insert,update,delete on mydb.* to &quot;user1&quot;@&quot;localhost&quot; identified by &quot;&quot;;grant all on *.* to &quot;user&quot;@&quot;localhost&quot; identified by &quot;password&quot;;# ALL PRIVILEGES 表示所有权限，你也可以使用select、update等权限。# ON 用来指定权限针对哪些库和表。# *.* 中前面的号用来指定数据库名，后面的号用来指定表名。# TO 表示将权限赋予某个用户。# @ 前面表示用户，@后面接限制的主机，可以是IP、IP段、域名以及%，%表示任何地方。# IDENTIFIED BY 指定用户的登录密码。# WITH GRANT OPTION 这个选项表示该用户可以将自己拥有的权限授权给别人。# 收回权限# revoke [权限] on [库.表] from [用户名]@[ip]revoke select on dyl.student from DYL@&#39;%&#39;# 修改权限之后记得刷新用户权限表flush privileges;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="备份数据库"><a href="#备份数据库" class="headerlink" title="备份数据库"></a>备份数据库</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 导出整个数据库mysqldump -u 用户名 -p 数据库名 &gt; 导出的文件名# 导出一个表mysqldump -u 用户名 -p 数据库名 表名 &gt; 导出的文件名# 导出一个数据库结构<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># drop user 用户名drop user &#39;jack&#39;@&#39;localhost&#39;;# DROP USER 语句可用于删除一个或多个 MySQL 账户，并撤销其原有权限# 使用 DROP USER 语句必须拥有 MySQL 中的 MySQL 数据库的 DELETE 权限或全局 CREATE USER 权限# 在 DROP USER 语句的使用中，若没有明确地给出账户的主机名，则该主机名默认为“%”# 注意：用户的删除不会影响他们之前所创建的表、索引或其他数据库对象，因为 MySQL 并不会记录是谁创建了这些对象。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="查看用户"><a href="#查看用户" class="headerlink" title="查看用户"></a>查看用户</h3><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">SELECT user,host FROM mysql.user;# 查看单个用户所有情况SELECT * FROM mysql.user WHERE user&#x3D;&#39;root&#39;\G# Select_priv：确定用户是否可以通过SELECT命令选择数据 # Insert_priv：确定用户是否可以通过INSERT命令插入数据 # Update_priv：确定用户是否可以通过UPDATE命令修改现有数据 # Delete_priv：确定用户是否可以通过DELETE命令删除现有数据 # Create_priv：确定用户是否可以创建新的数据库和表 # Drop_priv：确定用户是否可以删除现有数据库和表 # Reload_priv：确定用户是否可以执行刷新和重新加载MySQL所用各种内部缓存的特定命令，包括日志、权限、主机、查询和表 # Shutdown_priv：确定用户是否可以关闭MySQL服务器，将此权限提供给root账户之外的任何用户时，都应当非常谨慎 # Process_priv：确定用户是否可以通过SHOW # File_priv：确定用户是否可以执行SELECT INTO OUTFILE和LOAD DATA INFILE命令 # Grant_priv：确定用户是否可以将已经授予给该用户自己的权限再授予其他用户，例如，如果用户可以插入、选择和删除foo数据库中的信息，并且授予了GRANT权限，则该用户就可以将其任何或全部权限授予系统中的任何其他用户 # References_priv：目前只是某些未来功能的占位符，现在没有作用 # Alter_priv：确定用户是否可以重命名和修改表结构 # Show_db_priv：确定用户是否可以查看服务器上所有数据库的名字，包括用户拥有足够访问权限的数据库，可以考虑对所有用户禁用这个权限，除非有特别不可抗拒的原因 # Super_priv：确定用户是否可以执行某些强大的管理功能，例如通过KILL命令删除用户进程，使用SET GLOBAL修改全局MySQL变量，执行关于复制和日志的各种命令 # Create_tmp_table_priv：确定用户是否可以创建临时表 # Lock_tables_priv：确定用户是否可以使用LOCK # Execute_priv：确定用户是否可以执行存储过程，此权限只在MySQL 5.0及更高版本中有意义 # Repl_slave_priv：确定用户是否可以读取用于维护复制数据库环境的二进制日志文件，此用户位于主系统中，有利于主机和客户机之间的通信 # Repl_client_priv：确定用户是否可以确定复制从服务器和主服务器的位置 # Show_view_priv：确定用户是否可以查看视图或了解视图如何执行，此权限只在MySQL 5.0及更高版本中有意义 Create_routine_priv：确定用户是否可以更改或放弃存储过程和函数，此权限是在MySQL 5.0中引入的 Alter_routine_priv：确定用户是否可以修改或删除存储函数及函数，此权限是在MySQL 5.0中引入的 Create_user_priv：确定用户是否可以执行CREATE # Event_priv：确定用户能否创建、修改和删除事件，这个权限是MySQL 5.1.6新增的 # Trigger_priv：确定用户能否创建和删除触发器，这个权限是MySQL 5.1.6新增的# Create_tablespace_priv: 创建表的空间<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT实例</title>
      <link href="2021/06/21/QT/"/>
      <url>2021/06/21/QT/</url>
      
        <content type="html"><![CDATA[<h3 id="模拟cmd窗口"><a href="#模拟cmd窗口" class="headerlink" title="模拟cmd窗口"></a>模拟cmd窗口</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef WIDGET_H#define WIDGET_H#include &lt;QWidget&gt;#include &lt;QProcess&gt;#include &lt;QMessageBox&gt;namespace Ui &#123;class Widget;&#125;class Widget : public QWidget&#123;    Q_OBJECTpublic:    explicit Widget(QWidget *parent &#x3D; 0);    ~Widget();private slots:&#x2F;&#x2F; 将槽函数放在这里    void on_commitButton_clicked();    void on_cancelButton_clicked();private:    Ui::Widget *ui;&#125;;#endif &#x2F;&#x2F; WIDGET_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;Widget::Widget(QWidget *parent) :    QWidget(parent),    ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);&#x2F;&#x2F; 信号与槽函数的三种连接方式    connect(ui-&gt;comLineEdit,SIGNAL(returnPressed()),this,SLOT(on_commitButton_clicked()));    connect(ui-&gt;comLineEdit,&amp;QLineEdit::returnPressed,this,&amp;Widget::on_commitButton_clicked);            connect(ui-&gt;cancelButton,&amp;QPushButton::clicked,this,&amp;Widget::on_cancelButton_clicked);            &#x2F;&#x2F; 当槽函数的代码过少时可以考虑，这种连接方式，不需要额外的的槽函数    connect(ui-&gt;browsButton_3,&amp;QPushButton::clicked,[this]()&#123;        &#x2F;&#x2F; QMessageBox 产生弹窗,this表示当前的窗口是这个窗口的父类，需要添加#include &lt;QMessageBox&gt;        QMessageBox::information(this,&quot;左上角&quot;,&quot;内容&quot;);    &#125;);&#125;Widget::~Widget()&#123;    delete ui;&#125;void Widget::on_commitButton_clicked()&#123;    &#x2F;&#x2F; 获取文本框的数据    QString program&#x3D;ui-&gt;comLineEdit-&gt;text();    &#x2F;&#x2F; 运行程序，需要添加#include &lt;QProcess&gt;    QProcess *myProcess &#x3D; new QProcess(this);    myProcess-&gt;start(program);&#125;void Widget::on_cancelButton_clicked()&#123;    &#x2F;&#x2F; 关闭窗口    this-&gt;close();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;widget.h&quot;#include &lt;QApplication&gt;int main(int argc, char *argv[])&#123;    QApplication a(argc, argv);    Widget w;    w.show();    return a.exec();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210619183759735.png" alt="image-20210619183759735"></p><h3 id="计算器"><a href="#计算器" class="headerlink" title="计算器"></a>计算器</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;Widget::Widget(QWidget *parent) :    QWidget(parent),    ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);    &#x2F;&#x2F; 设置窗口的大小，使它不会因为拖动而改变大小    this-&gt;setMaximumSize(180,270);    this-&gt;setMinimumSize(180,270);    &#x2F;&#x2F; 设置标题    this-&gt;setWindowTitle(&quot;计算机&quot;);    &#x2F;&#x2F; 设置行编辑的字体和大小    QFont f(&quot;宋体&quot;,22);    ui-&gt;lineEdit-&gt;setFont(f);    &#x2F;&#x2F; 按钮贴上图片    QIcon Icon(&quot;C:\\Users\\地表最菜\\Pictures\\Saved Pictures\\test.jpg&quot;);    QSize IconSize(60,60);    ui-&gt;pushButton_back-&gt;setIcon(Icon);    ui-&gt;pushButton_back-&gt;setIconSize(IconSize);    &#x2F;&#x2F; 改变按钮背景色    ui-&gt;pushButton_equal-&gt;setStyleSheet(&quot;background:blue&quot;);    connect(ui-&gt;pushButton_0,&amp;QPushButton::clicked,this,&amp;Widget::clicked_Button_0);    connect(ui-&gt;pushButton_1,&amp;QPushButton::clicked,this,&amp;Widget::clicked_Button_1);    connect(ui-&gt;pushButton_2,&amp;QPushButton::clicked,this,&amp;Widget::clicked_Button_2);    connect(ui-&gt;pushButton_3,&amp;QPushButton::clicked,this,&amp;Widget::clicked_Button_3);    connect(ui-&gt;pushButton_4,&amp;QPushButton::clicked,this,&amp;Widget::clicked_Button_4);    connect(ui-&gt;pushButton_5,&amp;QPushButton::clicked,this,&amp;Widget::clicked_Button_5);    connect(ui-&gt;pushButton_6,&amp;QPushButton::clicked,this,&amp;Widget::clicked_Button_6);    connect(ui-&gt;pushButton_7,&amp;QPushButton::clicked,this,&amp;Widget::clicked_Button_7);    connect(ui-&gt;pushButton_8,&amp;QPushButton::clicked,this,&amp;Widget::clicked_Button_8);    connect(ui-&gt;pushButton_9,&amp;QPushButton::clicked,this,&amp;Widget::clicked_Button_9);    connect(ui-&gt;pushButton_muti,&amp;QPushButton::clicked,this,&amp;Widget::clicked_Button_muti);    connect(ui-&gt;pushButton_reduce,&amp;QPushButton::clicked,this,&amp;Widget::clicked_Button_reduce);    connect(ui-&gt;pushButton_add,&amp;QPushButton::clicked,this,&amp;Widget::clicked_Button_add);    connect(ui-&gt;pushButton_div,&amp;QPushButton::clicked,this,&amp;Widget::clicked_Button_div);    connect(ui-&gt;pushButton_equal,&amp;QPushButton::clicked,this,&amp;Widget::clicked_Button_equal);    connect(ui-&gt;pushButton_back,&amp;QPushButton::clicked,this,&amp;Widget::clicked_Button_back);    connect(ui-&gt;pushButton_Clear,&amp;QPushButton::clicked,this,&amp;Widget::clicked_Button_clear);    connect(ui-&gt;pushButton_right,&amp;QPushButton::clicked,this,&amp;Widget::clicked_Button_right);    connect(ui-&gt;pushButton_left,&amp;QPushButton::clicked,this,&amp;Widget::clicked_Button_left);&#125;Widget::~Widget()&#123;    delete ui;&#125;void Widget::clicked_Button_0()&#123;    expression+&#x3D;&#39;0&#39;;    &#x2F;&#x2F; 设置行编辑的输出    ui-&gt;lineEdit-&gt;setText(expression);&#125;void Widget::clicked_Button_1()&#123;    expression+&#x3D;&#39;1&#39;;    ui-&gt;lineEdit-&gt;setText(expression);&#125;void Widget::clicked_Button_2()&#123;    expression+&#x3D;&#39;2&#39;;    ui-&gt;lineEdit-&gt;setText(expression);&#125;void Widget::clicked_Button_3()&#123;    expression+&#x3D;&#39;3&#39;;    ui-&gt;lineEdit-&gt;setText(expression);&#125;void Widget::clicked_Button_4()&#123;    expression+&#x3D;&#39;4&#39;;    ui-&gt;lineEdit-&gt;setText(expression);&#125;void Widget::clicked_Button_5()&#123;    expression+&#x3D;&#39;5&#39;;    ui-&gt;lineEdit-&gt;setText(expression);&#125;void Widget::clicked_Button_6()&#123;    expression+&#x3D;&#39;6&#39;;    ui-&gt;lineEdit-&gt;setText(expression);&#125;void Widget::clicked_Button_7()&#123;    expression+&#x3D;&#39;7&#39;;    ui-&gt;lineEdit-&gt;setText(expression);&#125;void Widget::clicked_Button_8()&#123;    expression+&#x3D;&#39;8&#39;;    ui-&gt;lineEdit-&gt;setText(expression);&#125;void Widget::clicked_Button_9()&#123;    expression+&#x3D;&#39;9&#39;;    ui-&gt;lineEdit-&gt;setText(expression);&#125;void Widget::clicked_Button_muti()&#123;    expression+&#x3D;&#39;*&#39;;    ui-&gt;lineEdit-&gt;setText(expression);&#125;void Widget::clicked_Button_reduce()&#123;    expression+&#x3D;&#39;-&#39;;    ui-&gt;lineEdit-&gt;setText(expression);&#125;void Widget::clicked_Button_add()&#123;    expression+&#x3D;&#39;+&#39;;    ui-&gt;lineEdit-&gt;setText(expression);&#125;void Widget::clicked_Button_div()&#123;    expression+&#x3D;&#39;&#x2F;&#39;;    ui-&gt;lineEdit-&gt;setText(expression);&#125;void Widget::clicked_Button_equal()&#123;    expression.clear();    ui-&gt;lineEdit-&gt;clear();    expression+&#x3D;&quot;我也不知道，懒得写了&quot;;    ui-&gt;lineEdit-&gt;setText(expression);&#125;void Widget::clicked_Button_right()&#123;    expression+&#x3D;&#39;)&#39;;    ui-&gt;lineEdit-&gt;setText(expression);&#125;void Widget::clicked_Button_left()&#123;    expression+&#x3D;&#39;(&#39;;    ui-&gt;lineEdit-&gt;setText(expression);&#125;void Widget::clicked_Button_back()&#123;    &#x2F;&#x2F; 删除最后一位    expression.chop(1);    ui-&gt;lineEdit-&gt;setText(expression);&#125;void Widget::clicked_Button_clear()&#123;    expression.clear();    ui-&gt;lineEdit-&gt;clear();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;widget.h&quot;#include &lt;QApplication&gt;int main(int argc, char *argv[])&#123;    &#x2F;&#x2F; 解决设计时大小与运行之后大小相差太大的缺陷    if(QT_VERSION&gt;&#x3D;QT_VERSION_CHECK(5,6,0))            QCoreApplication::setAttribute(Qt::AA_EnableHighDpiScaling);    QApplication a(argc, argv);    Widget w;    w.show();    return a.exec();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef WIDGET_H#define WIDGET_H#include &lt;QWidget&gt;namespace Ui &#123;class Widget;&#125;class Widget : public QWidget&#123;    Q_OBJECTpublic:    explicit Widget(QWidget *parent &#x3D; 0);    ~Widget();private slots:    void clicked_Button_0();    void clicked_Button_1();    void clicked_Button_2();    void clicked_Button_3();    void clicked_Button_4();    void clicked_Button_5();    void clicked_Button_6();    void clicked_Button_7();    void clicked_Button_8();    void clicked_Button_9();    void clicked_Button_add();    void clicked_Button_reduce();    void clicked_Button_muti();    void clicked_Button_div();    void clicked_Button_equal();    void clicked_Button_back();    void clicked_Button_clear();    void clicked_Button_right();    void clicked_Button_left();private:    Ui::Widget *ui;    QString expression;&#125;;#endif &#x2F;&#x2F; WIDGET_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210619221525939.png" alt="image-20210619221525939"></p><h3 id="基于定时器与图片的相册"><a href="#基于定时器与图片的相册" class="headerlink" title="基于定时器与图片的相册"></a>基于定时器与图片的相册</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;Widget::Widget(QWidget *parent) :    QWidget(parent),    ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);    connect(ui-&gt;pushButton_start,&amp;QPushButton::clicked,this,&amp;Widget::pushButton_start_clicked);    connect(ui-&gt;pushButton_stop,&amp;QPushButton::clicked,this,&amp;Widget::pushButton_stop_clicked);    &#x2F;&#x2F; 显示图片    QPixmap pic(&quot;C:\\Users\\地表最菜\\Pictures\\Saved Pictures\\pic (1).png&quot;);    ui-&gt;label-&gt;setPixmap(pic);    namekey&#x3D;2;&#125;Widget::~Widget()&#123;    delete ui;&#125;void Widget::pushButton_start_clicked()&#123;    &#x2F;&#x2F; 开启定时器，返回定时器编号    &#x2F;&#x2F; 当时间到了发出信号调用timerEvent，之后又循环计时间    mytimerid&#x3D;this-&gt;startTimer(TIMEOUT);&#125;void Widget::timerEvent(QTimerEvent *event)&#123;    if(event-&gt;timerId()!&#x3D;mytimerid)&#123;        return;    &#125;        &#x2F;&#x2F; 拼接图片的路径    QString picname(&quot;C:\\Users\\地表最菜\\Pictures\\Saved Pictures\\pic (&quot;);    &#x2F;&#x2F; 将数字转换为QString    picname+&#x3D;QString::number(namekey);    picname+&#x3D;&quot;).png&quot;;        &#x2F;&#x2F; 让标签显示图片    QPixmap pic(picname);    ui-&gt;label-&gt;setPixmap(pic);    namekey++;    if(namekey&gt;&#x3D;12)        namekey&#x3D;1;&#125;void Widget::pushButton_stop_clicked()&#123;    &#x2F;&#x2F; 关闭定时器    this-&gt;killTimer(mytimerid);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef WIDGET_H#define WIDGET_H#include &lt;QWidget&gt;#include &lt;QPixmap&gt;#include &lt;QTimer&gt;#define TIMEOUT 2*1000namespace Ui &#123;class Widget;&#125;class Widget : public QWidget&#123;    Q_OBJECTpublic:    explicit Widget(QWidget *parent &#x3D; 0);    virtual void timerEvent(QTimerEvent *event);    ~Widget();private slots:    void pushButton_start_clicked();    void pushButton_stop_clicked();private:    Ui::Widget *ui;    int namekey;    int mytimerid;&#125;;#endif &#x2F;&#x2F; WIDGET_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;widget.h&quot;#include &lt;QApplication&gt;int main(int argc, char *argv[])&#123;    if(QT_VERSION&gt;&#x3D;QT_VERSION_CHECK(5,6,0))            QCoreApplication::setAttribute(Qt::AA_EnableHighDpiScaling);    QApplication a(argc, argv);    Widget w;    w.show();    return a.exec();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210620160028193.png" alt="image-20210620160028193"></p><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210620160257251.png" alt="image-20210620160257251"></p><blockquote><p>必须要勾上scaledContents，让图片自适应标签，否则图片会出现只会显示部分的情况</p></blockquote><h3 id="其它方式展示图片与定时器的功能"><a href="#其它方式展示图片与定时器的功能" class="headerlink" title="其它方式展示图片与定时器的功能"></a>其它方式展示图片与定时器的功能</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef WIDGET_H#define WIDGET_H#include &lt;QWidget&gt;#include &lt;QTimer&gt;#define TIMEOUT 2*1000namespace Ui &#123;class Widget;&#125;class Widget : public QWidget&#123;    Q_OBJECTpublic:    explicit Widget(QWidget *parent &#x3D; 0);    ~Widget();private slots:    void pushButton_start_clicked();    void pushButton_stop_clicked();    void pushButton_signal_clicked();    void myTimerEvent();private:    Ui::Widget *ui;    int picId;    QTimer *timer;&#125;;#endif &#x2F;&#x2F; WIDGET_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;Widget::Widget(QWidget *parent) :    QWidget(parent),    ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);    timer&#x3D;new QTimer;    connect(timer,&amp;QTimer::timeout,this,&amp;Widget::myTimerEvent);    connect(ui-&gt;pushButton_start,&amp;QPushButton::clicked,this,&amp;Widget::pushButton_start_clicked);    connect(ui-&gt;pushButton_stop,&amp;QPushButton::clicked,this,&amp;Widget::pushButton_stop_clicked);    connect(ui-&gt;pushButton_signal,&amp;QPushButton::clicked,this,&amp;Widget::pushButton_signal_clicked);    picId&#x3D;2;    QImage img;    img.load(&quot;C:\\Users\\地表最菜\\Pictures\\Saved Pictures\\pic (1).png&quot;);    ui-&gt;label-&gt;setPixmap(QPixmap::fromImage(img));&#125;Widget::~Widget()&#123;    delete ui;&#125;void Widget::pushButton_start_clicked()&#123;    timer-&gt;start(TIMEOUT);&#125;void Widget::myTimerEvent()&#123;    &#x2F;&#x2F; 文件路径名拼接    QString imgname(&quot;C:\\Users\\地表最菜\\Pictures\\Saved Pictures\\pic (&quot;);    imgname+&#x3D;QString::number(picId);    imgname+&#x3D;&quot;).png&quot;;    &#x2F;&#x2F; 图片显示    QImage img;    img.load(imgname);    ui-&gt;label-&gt;setPixmap(QPixmap::fromImage(img));    picId++;    if(picId&gt;&#x3D;12)        picId&#x3D;1;&#125;void Widget::pushButton_stop_clicked()&#123;    timer-&gt;stop();&#125;void Widget::pushButton_signal_clicked()&#123;    &#x2F;&#x2F; 单次定时    QTimer::singleShot(TIMEOUT,this,&amp;Widget::myTimerEvent);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;widget.h&quot;#include &lt;QApplication&gt;int main(int argc, char *argv[])&#123;    QApplication::setAttribute(Qt::AA_EnableHighDpiScaling);    QApplication a(argc, argv);    Widget w;    w.show();    return a.exec();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210620165623799.png" alt="image-20210620165623799"></p><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210620165709131.png" alt="image-20210620165709131"></p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef MAINWINDOW_H#define MAINWINDOW_H#include &lt;QMainWindow&gt;#include &lt;QFileDialog&gt;#include &lt;QMessageBox&gt;#include &lt;QDebug&gt;namespace Ui &#123;class MainWindow;&#125;class MainWindow : public QMainWindow&#123;    Q_OBJECTpublic:    explicit MainWindow(QWidget *parent &#x3D; 0);    ~MainWindow();private:    Ui::MainWindow *ui;private slots:    void open_file();    void save_file();    void new_file();&#125;;#endif &#x2F;&#x2F; MAINWINDOW_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;MainWindow::MainWindow(QWidget *parent) :    QMainWindow(parent),    ui(new Ui::MainWindow)&#123;    ui-&gt;setupUi(this);    connect(ui-&gt;action_new,&amp;QAction::triggered,this,&amp;MainWindow::new_file);    connect(ui-&gt;action_open,&amp;QAction::triggered,this,&amp;MainWindow::open_file);    connect(ui-&gt;action_save,&amp;QAction::triggered,this,&amp;MainWindow::save_file);&#125;MainWindow::~MainWindow()&#123;    delete ui;&#125;void MainWindow::new_file()&#123;    &#x2F;&#x2F; 清空内容    ui-&gt;textEdit-&gt;clear();    &#x2F;&#x2F; 修改窗口文字    this-&gt;setWindowTitle(&quot;新建一个文件&quot;);&#125;void MainWindow::open_file()&#123;    &#x2F;&#x2F; 选择文件，并且返回文件的路径，如果点击取消则会返回空，需要添加#include &lt;QFileDialog&gt;    &#x2F;&#x2F; applicationFilePath获取当前进程的路径,默认路径    &#x2F;&#x2F; .txt限制文件的类型，如果不写则代表所有的类型    QString fileName &#x3D; QFileDialog::getOpenFileName(this, &quot;打开一个文件&quot;,                                QApplication::applicationFilePath(),&quot;*.txt&quot;);    if(fileName.isEmpty())&#123;        &#x2F;&#x2F; 警告窗口，需要添加QMessageBox头文件        QMessageBox::warning(this,&quot;警告&quot;,&quot;请选择一个文件&quot;);    &#125;else&#123;        &#x2F;&#x2F; 在调试信息输出文件的名字        qDebug() &lt;&lt; fileName;        &#x2F;&#x2F; 打开文件，并且以只读方式打开        QFile file(fileName);        file.open(QIODevice::ReadOnly);        &#x2F;&#x2F; 读取文件，注意返回类型是QByteArray        QByteArray data&#x3D;file.readAll();        &#x2F;&#x2F; 修改textEdit里面的内容        ui-&gt;textEdit-&gt;setText(QString(data));        &#x2F;&#x2F; 注意关闭文件        file.close();    &#125;&#125;void MainWindow::save_file()&#123;    &#x2F;&#x2F; 打开要保存的路径，并且返回路径，如果不写第四个参数则代表所有的文件    QString fileName&#x3D;QFileDialog::getSaveFileName(this,&quot;保存文件&quot;,                                        QApplication::applicationFilePath());    if(fileName.isEmpty())&#123;        QMessageBox::warning(this,&quot;警告&quot;,&quot;请选择一个文件&quot;);    &#125;else&#123;        QFile file(fileName);        file.open(QIODevice::WriteOnly);        &#x2F;&#x2F; 获取textEdit里面的内容，返回的是QString        QString data&#x3D;ui-&gt;textEdit-&gt;toPlainText();        &#x2F;&#x2F; 将QString转换为QByteArray        QByteArray bytedata;        bytedata.append(data);        file.write(bytedata);        file.close();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;mainwindow.h&quot;#include &lt;QApplication&gt;int main(int argc, char *argv[])&#123;    QApplication::setAttribute(Qt::AA_EnableHighDpiScaling);    QApplication a(argc, argv);    MainWindow w;    w.show();    return a.exec();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210620193508066.png" alt="image-20210620193508066"></p><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210620193519914.png" alt="image-20210620193519914"></p><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210620193548573.png" alt="image-20210620193548573"></p><blockquote><p>注意UI时要加上&amp;符号，让用户可以通过键盘来实现点击操作</p></blockquote><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210620194024050.png" alt="image-20210620194024050"></p><h3 id="消息基础"><a href="#消息基础" class="headerlink" title="消息基础"></a>消息基础</h3><p>application能够知道哪个窗口在哪个位置，能知道应该由哪个窗口来接收消息，这个窗口会调用自己的消息处理函数</p><p>窗口的event()函数处理所有经过窗口的消息</p><p>消息处理函数是虚函数，使用要进行重载</p><p>常见的QT事件类型如下：</p><ul><li>键盘事件：按键按下和松开</li><li>鼠标事件：鼠标移动，鼠标按键的按下和松开</li><li>拖放事件：用鼠标进行拖放</li><li>滚轮事件：鼠标滚轮滚动</li><li>绘屏事件：重绘屏幕的某些部分</li><li>定时事件：定时器到时</li><li>焦点事件：键盘焦点移动</li><li>进入和离开事件：鼠标移动widget之内，或是移出</li><li>移动事件：widget的位置改变</li><li>大小改变事件：widget的大小改变</li><li>显示和隐藏事件：widget显示和隐藏</li><li>窗口事件：窗口是否为当前窗口</li></ul><p>QT将系统产生的消息转化为QT事件，QT事件被封装为对象，所有的QT事件均继承抽象类QEvent，用于描述内部或外部发生的动作，任意的QObject对象都具备处理QT事件的能力。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef MAINWINDOW_H#define MAINWINDOW_H#include &lt;QMainWindow&gt;#include &lt;QFileDialog&gt;#include &lt;QMessageBox&gt;#include &lt;QDebug&gt;#include &lt;QMouseEvent&gt;#include &lt;QKeyEvent&gt;namespace Ui &#123;class MainWindow;&#125;class MainWindow : public QMainWindow&#123;    Q_OBJECTpublic:    explicit MainWindow(QWidget *parent &#x3D; 0);    &#x2F;&#x2F; 重载键盘事件    virtual void keyPressEvent(QKeyEvent *k);    &#x2F;&#x2F; 重载鼠标事件    virtual void mousePressEvent(QMouseEvent *m);    ~MainWindow();private:    Ui::MainWindow *ui;private slots:    void open_file();    void save_file();    void new_file();&#125;;#endif &#x2F;&#x2F; MAINWINDOW_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;mainwindow.h&quot;#include &quot;ui_mainwindow.h&quot;MainWindow::MainWindow(QWidget *parent) :    QMainWindow(parent),    ui(new Ui::MainWindow)&#123;    ui-&gt;setupUi(this);    connect(ui-&gt;action_new,&amp;QAction::triggered,this,&amp;MainWindow::new_file);    connect(ui-&gt;action_open,&amp;QAction::triggered,this,&amp;MainWindow::open_file);    connect(ui-&gt;action_save,&amp;QAction::triggered,this,&amp;MainWindow::save_file);&#125;MainWindow::~MainWindow()&#123;    delete ui;&#125;void MainWindow::new_file()&#123;    &#x2F;&#x2F; 清空内容    ui-&gt;textEdit-&gt;clear();    &#x2F;&#x2F; 修改窗口文字    this-&gt;setWindowTitle(&quot;新建一个文件&quot;);&#125;void MainWindow::open_file()&#123;    &#x2F;&#x2F; 选择文件，并且返回文件的路径，如果点击取消则会返回空，需要添加#include &lt;QFileDialog&gt;    &#x2F;&#x2F; applicationFilePath获取当前进程的路径,默认路径    &#x2F;&#x2F; .txt限制文件的类型，如果不写则代表所有的类型    QString fileName &#x3D; QFileDialog::getOpenFileName(this, &quot;打开一个文件&quot;,                                QApplication::applicationFilePath(),&quot;*.txt&quot;);    if(fileName.isEmpty())&#123;        &#x2F;&#x2F; 警告窗口，需要添加QMessageBox头文件        QMessageBox::warning(this,&quot;警告&quot;,&quot;请选择一个文件&quot;);    &#125;else&#123;        &#x2F;&#x2F; 在调试信息输出文件的名字        qDebug() &lt;&lt; fileName;        &#x2F;&#x2F; 打开文件，并且以只读方式打开        QFile file(fileName);        file.open(QIODevice::ReadOnly);        &#x2F;&#x2F; 读取文件，注意返回类型是QByteArray        QByteArray data&#x3D;file.readAll();        &#x2F;&#x2F; 修改textEdit里面的内容        ui-&gt;textEdit-&gt;setText(QString(data));        &#x2F;&#x2F; 注意关闭文件        file.close();    &#125;&#125;void MainWindow::save_file()&#123;    &#x2F;&#x2F; 打开要保存的路径，并且返回路径，如果不写第四个参数则代表所有的文件    QString fileName&#x3D;QFileDialog::getSaveFileName(this,&quot;保存文件&quot;,                                        QApplication::applicationFilePath());    if(fileName.isEmpty())&#123;        QMessageBox::warning(this,&quot;警告&quot;,&quot;请选择一个文件&quot;);    &#125;else&#123;        QFile file(fileName);        file.open(QIODevice::WriteOnly);        &#x2F;&#x2F; 获取textEdit里面的内容，返回的是QString        QString data&#x3D;ui-&gt;textEdit-&gt;toPlainText();        &#x2F;&#x2F; 将QString转换为QByteArray        QByteArray bytedata;        bytedata.append(data);        file.write(bytedata);        file.close();    &#125;&#125;void MainWindow::keyPressEvent(QKeyEvent *k)&#123;    &#x2F;&#x2F; 实现ctrl+s保存文件    &#x2F;&#x2F; 需要添加头文件，#include &lt;QMouseEvent&gt;    &#x2F;&#x2F; 可以通过帮助搜素查找函数和宏    &#x2F;&#x2F; modifiers查看热键是否被按下,key代表普通键是否被按下    if(k-&gt;modifiers()&#x3D;&#x3D;Qt::ControlModifier&amp;&amp;k-&gt;key()&#x3D;&#x3D;Qt::Key_S)&#123;        save_file();    &#125;&#125;void MainWindow::mousePressEvent(QMouseEvent *m)&#123;    &#x2F;&#x2F; 需要添加头文件，#include &lt;QKeyEvent&gt;    &#x2F;&#x2F; pos函数返回坐标    qDebug()&lt;&lt;m-&gt;pos();    if(m-&gt;button()&#x3D;&#x3D;Qt::LeftButton)&#123;        qDebug()&lt;&lt;&quot;按下左键&quot;;    &#125;else if(m-&gt;button()&#x3D;&#x3D;Qt::RightButton)&#123;        qDebug()&lt;&lt;&quot;按下右键&quot;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef WIDGET_H#define WIDGET_H#include &lt;QWidget&gt;#include &lt;QTcpSocket&gt;#include &lt;QMessageBox&gt;#include &lt;QHostAddress&gt;namespace Ui &#123;class Widget;&#125;class Widget : public QWidget&#123;    Q_OBJECTpublic:    explicit Widget(QWidget *parent &#x3D; 0);    ~Widget();private slots:    void buttonCommitClicked(void);    void buttonCancelClicked(void);private:    Ui::Widget *ui;    QTcpSocket *socket;&#125;;#endif &#x2F;&#x2F; WIDGET_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;Widget::Widget(QWidget *parent) :    QWidget(parent),    ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);    connect(ui-&gt;pushButton_Commit,&amp;QPushButton::clicked,this,&amp;Widget::buttonCommitClicked);    connect(ui-&gt;pushButton_Cancel,&amp;QPushButton::clicked,this,&amp;Widget::buttonCancelClicked);    &#x2F;&#x2F; 初始化socket    socket&#x3D;new QTcpSocket;&#125;Widget::~Widget()&#123;    delete ui;&#125;void Widget::buttonCommitClicked(void)&#123;    &#x2F;&#x2F; 获取ip和端口号    QString ip&#x3D;ui-&gt;lineEdit_Ip-&gt;text();    QString port&#x3D;ui-&gt;lineEdit_Port-&gt;text();    &#x2F;&#x2F; 连接服务器    socket-&gt;connectToHost(QHostAddress(ip),port.toShort());    &#x2F;&#x2F; 连接状态提醒    connect(socket,&amp;QTcpSocket::connected,[this]()&#123;        QMessageBox::information(this,&quot;连接提示&quot;,&quot;连接成功&quot;);    &#125;);    connect(socket,&amp;QTcpSocket::disconnected,[this]()&#123;        QMessageBox::warning(this,&quot;连接提示&quot;,&quot;连接失败&quot;);    &#125;);&#125;void Widget::buttonCancelClicked(void)&#123;    this-&gt;close();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;widget.h&quot;#include &lt;QApplication&gt;int main(int argc, char *argv[])&#123;    QApplication::setAttribute(Qt::AA_EnableHighDpiScaling);    QApplication a(argc, argv);    Widget w;    w.show();    return a.exec();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：必须修改.pro工程文件，在第七行QT末尾加上network</p></blockquote><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210623190529323.png" alt="image-20210623190529323"></p><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210623190554262.png" alt="image-20210623190554262"></p><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef WIDGET_H#define WIDGET_H#include &lt;QWidget&gt;#include &lt;QTcpServer&gt;#include &lt;QTcpSocket&gt;#include &lt;QHostAddress&gt;#define PORT 8000namespace Ui &#123;class Widget;&#125;class Widget : public QWidget&#123;    Q_OBJECTpublic:    explicit Widget(QWidget *parent &#x3D; 0);    ~Widget();private slots:    void newConnectHander(void);private:    Ui::Widget *ui;    QTcpServer *server;&#125;;#endif &#x2F;&#x2F; WIDGET_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;Widget::Widget(QWidget *parent) :    QWidget(parent),    ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);    server&#x3D;new QTcpServer;    &#x2F;&#x2F; 进入监听状态    &#x2F;&#x2F; 需要QHostAddress和QTcpServer头文件    server-&gt;listen(QHostAddress::AnyIPv4,PORT);    &#x2F;&#x2F; 当出现连接时运行函数    connect(server,&amp;QTcpServer::newConnection,this,&amp;Widget::newConnectHander);&#125;Widget::~Widget()&#123;    delete ui;&#125;void Widget::newConnectHander(void)&#123;    &#x2F;&#x2F; 建立TCP连接    &#x2F;&#x2F; 需要QTcpSocket头文件    QTcpSocket *s&#x3D;server-&gt;nextPendingConnection();    &#x2F;&#x2F; 获取客户端的IP地址    &#x2F;&#x2F; 将QHostAddress类型转换为QString类型    ui-&gt;lineEdit_IP-&gt;setText(s-&gt;peerAddress().toString());    &#x2F;&#x2F; 获取客户端的端口号，端口号很有可能与服务器端口号不一样    &#x2F;&#x2F; 将数字类型转换为QString类型    ui-&gt;lineEdit_PORT-&gt;setText(QString::number(s-&gt;peerPort()));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;widget.h&quot;#include &lt;QApplication&gt;int main(int argc, char *argv[])&#123;    QApplication::setAttribute(Qt::AA_EnableHighDpiScaling);    QApplication a(argc, argv);    Widget w;    w.show();    return a.exec();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210623190836006.png" alt="image-20210623190836006"></p><blockquote><p>注意：必须修改.pro工程文件，在第七行QT末尾加上network</p></blockquote><h3 id="在TCP客户端基础实现信息传输"><a href="#在TCP客户端基础实现信息传输" class="headerlink" title="在TCP客户端基础实现信息传输"></a>在TCP客户端基础实现信息传输</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef CHAT_H#define CHAT_H#include &lt;QWidget&gt;#include &lt;QTcpSocket&gt;namespace Ui &#123;class Chat;&#125;class Chat : public QWidget&#123;    Q_OBJECTpublic:    explicit Chat(QTcpSocket* socket,QWidget *parent &#x3D; 0);    ~Chat();private slots:    void sendMessage(void);    void recvMessage(void);    void clearMessage(void);private:    Ui::Chat *ui;    QTcpSocket *socket;&#125;;#endif &#x2F;&#x2F; CHAT_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;QTcpSocket&gt;#include &lt;QMessageBox&gt;#include &lt;QHostAddress&gt;namespace Ui &#123;class Widget;&#125;class Widget : public QWidget&#123;    Q_OBJECTpublic:    explicit Widget(QWidget *parent &#x3D; 0);    ~Widget();private slots:    void buttonCommitClicked(void);    void buttonCancelClicked(void);private:    Ui::Widget *ui;    QTcpSocket *socket;&#125;;#endif &#x2F;&#x2F; WIDGET_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;chat.h&quot;#include &quot;ui_chat.h&quot;Chat::Chat(QTcpSocket *socket, QWidget *parent) :    QWidget(parent),    ui(new Ui::Chat)&#123;    ui-&gt;setupUi(this);    this-&gt;socket&#x3D;socket;    &#x2F;&#x2F; 服务器发送数据到客户端，客户端会产生readyRead信号    connect(socket,&amp;QTcpSocket::readyRead,this,&amp;Chat::recvMessage);    connect(ui-&gt;pushButtonSend,&amp;QPushButton::clicked,this,&amp;Chat::sendMessage);    connect(ui-&gt;pushButtonClear,&amp;QPushButton::clicked,this,&amp;Chat::clearMessage);&#125;Chat::~Chat()&#123;    delete ui;&#125;void Chat::recvMessage()&#123;    &#x2F;&#x2F; 将QByteArray类型转换为QString    &#x2F;&#x2F; 读出数据    ui-&gt;lineEditRecv-&gt;setText(QString(socket-&gt;readAll()));&#125;void Chat::sendMessage()&#123;    QByteArray data;    &#x2F;&#x2F; 将QString转换为QByteArray类型    data.append(ui-&gt;lineEditSend-&gt;text());    &#x2F;&#x2F; 写数据    socket-&gt;write(data);    ui-&gt;lineEditSend-&gt;clear();&#125;void Chat::clearMessage()&#123;    ui-&gt;lineEditRecv-&gt;clear();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;#include &quot;chat.h&quot;Widget::Widget(QWidget *parent) :    QWidget(parent),    ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);    connect(ui-&gt;pushButton_Commit,&amp;QPushButton::clicked,this,&amp;Widget::buttonCommitClicked);    connect(ui-&gt;pushButton_Cancel,&amp;QPushButton::clicked,this,&amp;Widget::buttonCancelClicked);    &#x2F;&#x2F; 初始化socket    socket&#x3D;new QTcpSocket;&#125;Widget::~Widget()&#123;    delete ui;&#125;void Widget::buttonCommitClicked(void)&#123;    &#x2F;&#x2F; 获取ip和端口号    QString ip&#x3D;ui-&gt;lineEdit_Ip-&gt;text();    QString port&#x3D;ui-&gt;lineEdit_Port-&gt;text();    &#x2F;&#x2F; 连接服务器    socket-&gt;connectToHost(QHostAddress(ip),port.toShort());    &#x2F;&#x2F; 连接状态提醒    connect(socket,&amp;QTcpSocket::connected,[this]()&#123;        QMessageBox::information(this,&quot;连接提示&quot;,&quot;连接成功&quot;);        &#x2F;&#x2F; 注意这里必须使用堆空间，如果使用栈空间当函数运行完毕会被释放        Chat *c&#x3D;new Chat(socket);        &#x2F;&#x2F; 展示窗口        c-&gt;show();        &#x2F;&#x2F; 隐藏现在这个窗口        this-&gt;hide();    &#125;);    connect(socket,&amp;QTcpSocket::disconnected,[this]()&#123;        QMessageBox::warning(this,&quot;连接提示&quot;,&quot;连接失败&quot;);    &#125;);&#125;void Widget::buttonCancelClicked(void)&#123;    this-&gt;close();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;widget.h&quot;#include &lt;QApplication&gt;int main(int argc, char *argv[])&#123;    QApplication::setAttribute(Qt::AA_EnableHighDpiScaling);    QApplication a(argc, argv);    Widget w;    w.show();    return a.exec();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210623202851406.png" alt="image-20210623202851406"></p><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210623202913173.png" alt="image-20210623202913173"></p><h3 id="TCP服务器基础上实现信息传输"><a href="#TCP服务器基础上实现信息传输" class="headerlink" title="TCP服务器基础上实现信息传输"></a>TCP服务器基础上实现信息传输</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef CHATSERVER_H#define CHATSERVER_H#include &lt;QWidget&gt;#include &lt;QTcpSocket&gt;namespace Ui &#123;class ChatServer;&#125;class ChatServer : public QWidget&#123;    Q_OBJECTpublic:    explicit ChatServer(QTcpSocket *socket, QWidget *parent &#x3D; 0);    ~ChatServer();private slots:    void SendMessage(void);    void RecvMessage(void);    void ClearMessage(void);private:    Ui::ChatServer *ui;    QTcpSocket *socket;&#125;;#endif &#x2F;&#x2F; CHATSERVER_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef WIDGET_H#define WIDGET_H#include &lt;QWidget&gt;#include &lt;QTcpServer&gt;#include &lt;QTcpSocket&gt;#include &lt;QHostAddress&gt;#define PORT 8000namespace Ui &#123;class Widget;&#125;class Widget : public QWidget&#123;    Q_OBJECTpublic:    explicit Widget(QWidget *parent &#x3D; 0);    ~Widget();private slots:    void newConnectHander(void);private:    Ui::Widget *ui;    QTcpServer *server;&#125;;#endif &#x2F;&#x2F; WIDGET_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;chatserver.h&quot;#include &quot;ui_chatserver.h&quot;ChatServer::ChatServer(QTcpSocket *socket, QWidget *parent) :    QWidget(parent),    ui(new Ui::ChatServer)&#123;    ui-&gt;setupUi(this);    this-&gt;socket&#x3D;socket;    connect(socket,&amp;QTcpSocket::readyRead,this,&amp;ChatServer::RecvMessage);    connect(ui-&gt;pushButtonSend,&amp;QPushButton::clicked,this,&amp;ChatServer::SendMessage);    connect(ui-&gt;pushButtonClear,&amp;QPushButton::clicked,this,&amp;ChatServer::ClearMessage);&#125;ChatServer::~ChatServer()&#123;    delete ui;&#125;void ChatServer::RecvMessage()&#123;    &#x2F;&#x2F; 获取信号的发送者    QTcpSocket *s&#x3D;(QTcpSocket *)sender();    ui-&gt;lineEditRecv-&gt;setText(QString(s-&gt;readAll()));&#125;void ChatServer::SendMessage()&#123;    QByteArray data;    data.append(ui-&gt;lineEditSend-&gt;text());    socket-&gt;write(data);    ui-&gt;lineEditSend-&gt;clear();&#125;void ChatServer::ClearMessage()&#123;    ui-&gt;lineEditRecv-&gt;clear();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;widget.h&quot;#include &lt;QApplication&gt;int main(int argc, char *argv[])&#123;    QApplication::setAttribute(Qt::AA_EnableHighDpiScaling);    QApplication a(argc, argv);    Widget w;    w.show();    return a.exec();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;#include &quot;chatserver.h&quot;Widget::Widget(QWidget *parent) :    QWidget(parent),    ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);    server&#x3D;new QTcpServer;    &#x2F;&#x2F; 进入监听状态    &#x2F;&#x2F; 需要QHostAddress和QTcpServer头文件    server-&gt;listen(QHostAddress::AnyIPv4,PORT);    &#x2F;&#x2F; 当出现连接时运行函数    connect(server,&amp;QTcpServer::newConnection,this,&amp;Widget::newConnectHander);&#125;Widget::~Widget()&#123;    delete ui;&#125;void Widget::newConnectHander(void)&#123;    &#x2F;&#x2F; 建立TCP连接    &#x2F;&#x2F; 需要QTcpSocket头文件    QTcpSocket *s&#x3D;server-&gt;nextPendingConnection();    &#x2F;&#x2F; 获取客户端的IP地址    &#x2F;&#x2F; 将QHostAddress类型转换为QString类型    ui-&gt;lineEdit_IP-&gt;setText(s-&gt;peerAddress().toString());    &#x2F;&#x2F; 获取客户端的端口号，端口号很有可能与服务器端口号不一样    &#x2F;&#x2F; 将数字类型转换为QString类型    ui-&gt;lineEdit_PORT-&gt;setText(QString::number(s-&gt;peerPort()));    ChatServer *chat&#x3D;new ChatServer(s);    chat-&gt;show();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>创建新窗口的操作与在TCP客户端基础实现信息传输是一样的</p></blockquote><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210623203243186.png" alt="image-20210623203243186"></p><h3 id="多线程和自定义信号"><a href="#多线程和自定义信号" class="headerlink" title="多线程和自定义信号"></a>多线程和自定义信号</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef MYTHREAD_H#define MYTHREAD_H#include &lt;QObject&gt;#include &lt;QThread&gt;#include &lt;QTcpSocket&gt;class myThread:public QThread&#123;    Q_OBJECTpublic:    myThread(QTcpSocket *socket);    &#x2F;&#x2F; 线程运行函数    void run();private slots:    void handleData(void);signals:    &#x2F;&#x2F; 创建信号    void sendData(QByteArray data);private:    QTcpSocket *socket;&#125;;#endif &#x2F;&#x2F; MYTHREAD_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef WIDGET_H#define WIDGET_H#include &lt;QWidget&gt;#include &lt;QTcpServer&gt;#include &lt;QTcpSocket&gt;#define PORT 8000namespace Ui &#123;class Widget;&#125;class Widget : public QWidget&#123;    Q_OBJECTpublic:    explicit Widget(QWidget *parent &#x3D; 0);    ~Widget();private slots:    void newConnectHander(void);    void handData(QByteArray data);private:    Ui::Widget *ui;    QTcpServer *server;&#125;;#endif &#x2F;&#x2F; WIDGET_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;mythread.h&quot;myThread::myThread(QTcpSocket *socket)&#123;    &#x2F;&#x2F; 接收socket    this-&gt;socket&#x3D;socket;&#125;void myThread::run()&#123;    &#x2F;&#x2F; 当有可读事件时用handleData函数处理    connect(socket,&amp;QTcpSocket::readyRead,this,&amp;myThread::handleData);&#125;void myThread::handleData()&#123;    QByteArray data;    data&#x3D;socket-&gt;readAll();    &#x2F;&#x2F; 发送信号,不能通过传参的方式对ui进行修改，ui只能自己类可以进行修改    emit sendData(data);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;#include &quot;mythread.h&quot;Widget::Widget(QWidget *parent) :    QWidget(parent),    ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);    server&#x3D;new QTcpServer;    server-&gt;listen(QHostAddress::AnyIPv4,PORT);    connect(server,&amp;QTcpServer::newConnection,this,&amp;Widget::newConnectHander);&#125;Widget::~Widget()&#123;    delete ui;&#125;void Widget::newConnectHander(void)&#123;    QTcpSocket *s&#x3D;server-&gt;nextPendingConnection();    ui-&gt;lineEditIp-&gt;setText(s-&gt;peerAddress().toString());    ui-&gt;lineEditPort-&gt;setText(QString::number(s-&gt;peerPort()));    myThread *thread&#x3D;new myThread(s);    &#x2F;&#x2F; 开始线程    thread-&gt;start();    &#x2F;&#x2F; 处理thread发出来的sendData信号    connect(thread,&amp;myThread::sendData,this,&amp;Widget::handData);&#125;void Widget::handData(QByteArray data)&#123;    ui-&gt;lineEditShow-&gt;setText(QString(data));&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;widget.h&quot;#include &lt;QApplication&gt;int main(int argc, char *argv[])&#123;    QApplication::setAttribute(Qt::AA_EnableHighDpiScaling);    QApplication a(argc, argv);    Widget w;    w.show();    return a.exec();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>ui只能在自己类才可以进行修改</p></blockquote><h3 id="连接MYSQL数据库"><a href="#连接MYSQL数据库" class="headerlink" title="连接MYSQL数据库"></a>连接MYSQL数据库</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef WIDGET_H#define WIDGET_H#include &lt;QWidget&gt;#include &lt;QSqlDatabase&gt;#include &lt;QMessageBox&gt;#include &lt;QSqlQuery&gt;#include &lt;QDebug&gt;namespace Ui &#123;class Widget;&#125;class Widget : public QWidget&#123;    Q_OBJECTpublic:    explicit Widget(QWidget *parent &#x3D; 0);    ~Widget();private slots:    void insertButton(void);    void cancelButton(void);private:    Ui::Widget *ui;&#125;;#endif &#x2F;&#x2F; WIDGET_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;Widget::Widget(QWidget *parent) :    QWidget(parent),    ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);    &#x2F;&#x2F; 加载mysql驱动    QSqlDatabase base&#x3D;QSqlDatabase::addDatabase(&quot;QMYSQL&quot;);    base.setHostName(&quot;47.108.71.9&quot;);    base.setDatabaseName(&quot;dyl&quot;);    base.setUserName(&quot;DYL&quot;);    base.setPassword(&quot;199911&quot;);    &#x2F;&#x2F; open成功返回true，失败返回false    if(base.open())&#123;        QMessageBox::information(this,&quot;连接提示&quot;,&quot;连接成功&quot;);    &#125;else&#123;        QMessageBox::warning(this,&quot;连接提示&quot;,&quot;连接失败&quot;);    &#125;    connect(ui-&gt;pushButtonCheck,&amp;QPushButton::clicked,this,&amp;Widget::cancelButton);    connect(ui-&gt;pushButtonInsert,&amp;QPushButton::clicked,this,&amp;Widget::insertButton);&#125;Widget::~Widget()&#123;    delete ui;&#125;void Widget::insertButton()&#123;    QString id&#x3D;ui-&gt;lineEditId-&gt;text();    QString name&#x3D;ui-&gt;lineEditName-&gt;text();    QString sex&#x3D;ui-&gt;lineEditSex-&gt;text();    QString birth&#x3D;ui-&gt;lineEditBirthday-&gt;text();    QString sclass&#x3D;ui-&gt;lineEditClass-&gt;text();    QString command&#x3D;QString(&quot;insert into student values(&#39;%1&#39;,&#39;%2&#39;,&#39;%3&#39;,&#39;%4&#39;,&#39;%5&#39;);&quot;).arg(id).arg(name).arg(sex).arg(birth).arg(sclass);    &#x2F;&#x2F; 操作数据库的对象,需要头文件    QSqlQuery data;    if(data.exec(command))&#123;        QMessageBox::information(this,&quot;插入提示&quot;,&quot;插入成功&quot;);    &#125;else&#123;        QMessageBox::warning(this,&quot;插入提示&quot;,&quot;插入失败&quot;);    &#125;&#125;void Widget::cancelButton()&#123;    QSqlQuery data;    QString command(&quot;select * from student;&quot;);        data.exec(command);    while(data.next())&#123;        qDebug()&lt;&lt;data.value(0);        qDebug()&lt;&lt;data.value(1);        qDebug()&lt;&lt;data.value(2);        qDebug()&lt;&lt;data.value(3);        qDebug()&lt;&lt;data.value(4);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;widget.h&quot;#include &lt;QApplication&gt;int main(int argc, char *argv[])&#123;    QApplication::setAttribute(Qt::AA_EnableHighDpiScaling);    QApplication a(argc, argv);    Widget w;    w.show();    return a.exec();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意：需要在工程文件.pro下加入sql，而且必须在qc的lib库中加入libmysql.dll文件，不然无法加载驱动</p></blockquote><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210625200335598.png" alt="image-20210625200335598"></p><h3 id="使用模型显示数据库表"><a href="#使用模型显示数据库表" class="headerlink" title="使用模型显示数据库表"></a>使用模型显示数据库表</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef WIDGET_H#define WIDGET_H#include &lt;QWidget&gt;#include &lt;QSqlDatabase&gt;#include &lt;QMessageBox&gt;#include &lt;QSqlTableModel&gt;namespace Ui &#123;class Widget;&#125;class Widget : public QWidget&#123;    Q_OBJECTpublic:    explicit Widget(QWidget *parent &#x3D; 0);    ~Widget();private slots:    void checkButton(void);private:    Ui::Widget *ui;    QSqlTableModel *view;&#125;;#endif &#x2F;&#x2F; WIDGET_H<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;widget.h&quot;#include &quot;ui_widget.h&quot;Widget::Widget(QWidget *parent) :    QWidget(parent),    ui(new Ui::Widget)&#123;    ui-&gt;setupUi(this);    QSqlDatabase db&#x3D;QSqlDatabase::addDatabase(&quot;QMYSQL&quot;);    db.setHostName(&quot;47.108.71.9&quot;);    db.setDatabaseName(&quot;dyl&quot;);    db.setUserName(&quot;DYL&quot;);    db.setPassword(&quot;199911&quot;);    if(db.open())&#123;        QMessageBox::information(this,&quot;连接提示&quot;,&quot;连接成功&quot;);                view&#x3D;new QSqlTableModel;        &#x2F;&#x2F; 模型与表进行关联        view-&gt;setTable(&quot;student&quot;);        &#x2F;&#x2F; 模型与界面进行关联        ui-&gt;tableView-&gt;setModel(view);        connect(ui-&gt;checkButton,&amp;QPushButton::clicked,this,&amp;Widget::checkButton);    &#125;else&#123;        QMessageBox::warning(this,&quot;连接提示&quot;,&quot;连接失败&quot;);    &#125;&#125;Widget::~Widget()&#123;    delete ui;&#125;void Widget::checkButton()&#123;    &#x2F;&#x2F; 显示出表    view-&gt;select();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;widget.h&quot;#include &lt;QApplication&gt;int main(int argc, char *argv[])&#123;    QApplication::setAttribute(Qt::AA_EnableHighDpiScaling);    QApplication a(argc, argv);    Widget w;    w.show();    return a.exec();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210625203515935.png" alt="image-20210625203515935"></p><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210625203807823.png" alt="image-20210625203807823"></p>]]></content>
      
      
      
        <tags>
            
            <tag> QT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Json-c API使用</title>
      <link href="2021/06/21/Json-c/"/>
      <url>2021/06/21/Json-c/</url>
      
        <content type="html"><![CDATA[<h2 id="JSON-C库安装"><a href="#JSON-C库安装" class="headerlink" title="JSON-C库安装"></a>JSON-C库安装</h2><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 安装工具sudo apt install gitsudo apt install autoconf automake libtoolsudo apt install valgrind # optional# 下载源码wget https:&#x2F;&#x2F;github.com&#x2F;json-c&#x2F;json-c&#x2F;archive&#x2F;json-c-0.14-20200419.tar.gz -O json-c.tar.gztar zxvf json-c.tar.gzmv json-c-json-c-0.14-20200419 json-c# 编译安装mkdir json-c-build &amp;&amp; cd json-c-buildcmake ..&#x2F;json-cmakemake testmake USE_VALGRIND&#x3D;0 testmake install# 至此安装成功# 头文件目录&#x2F;usr&#x2F;local&#x2F;include# 动态库目录&#x2F;lib&#x2F;x86_64-linux-gnu 或者 &#x2F;usr&#x2F;local&#x2F;lib# 合法的json实例&#123;&quot;name&quot;:&quot;jack&quot;,&quot;sex&quot;:&quot;male&quot;&#125;&#123;&quot;name&quot;:&quot;jack&quot;,&quot;age&quot;:18,&quot;address&quot;:&#123;&quot;country&quot;:&quot;china&quot;,&quot;zip-code&quot;:&quot;100000&quot;&#125;&#125;&#123;&quot;a&quot;:1,&quot;b&quot;:[1,2,3]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="JSON-C库的使用"><a href="#JSON-C库的使用" class="headerlink" title="JSON-C库的使用"></a>JSON-C库的使用</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 将符合json格式的字符串构造为一个json对象struct json_object *json_tokener_parse(const char *);&#x2F;&#x2F; 将json对象内容，转成json格式的字符串const char *json_object_to_json_string(struct json_object *obj);&#x2F;&#x2F; 创建json对象struct json_object *json_object_new_object();&#x2F;&#x2F; 往json独享中添加键值对void json_object_object_add(struct json_object *obj,const char *key,struct json_object *value);&#x2F;&#x2F; 将C字符串转换为JSON字符串格式的对象struct json_object *json_object_new_string(const char *s);&#x2F;&#x2F; 将整数转换为JSON格式的对象struct json_object *json_object_new_int(int32_t i);&#x2F;&#x2F; 获取json对象的整形数值int32_t json_object_get_int(struct json_object *obj);&#x2F;&#x2F; 获取json对象的字符串值const char *json_object_get_string(struct json_object *obj);&#x2F;&#x2F; 解析json分为两步：&#x2F;&#x2F; 第一步：根据键名，从json对象中获取对应数据的json对象&#x2F;&#x2F; 第二步：根据数据类型，将数据对应的json对象转化为对应类型的数据&#x2F;&#x2F; 根据键名获取对应的json对象json_bool json_object_object_get_ex(struct json_object *obj,const char *key,struct json_object **value);&#x2F;&#x2F; 参数：obj源json对象，key键名，value用于存放获取的对应数据的json对象，注意这里一定传入的是二级指针，不用传入实体&#x2F;&#x2F; 获取json对象的类型 类型有：json_type_null json_type_boolean json_type_double json_type_int json_type_object json_type_array json_type_stringjson_type json_object_get_type(struct json_object *obj);&#x2F;&#x2F; 数组类型相关操作(json_type_array类型)&#x2F;&#x2F; 创建一个JSON数组类型JSON对象struct json_object *json_object_new_array(void);&#x2F;&#x2F; 往json_type_array类型的json对象中添加一个元素int json_object_array_add(struct json_object *obj,struct json_object *val);&#x2F;&#x2F; 获取json_type_array类型的json对象中指定下标的元素struct json_object *json_object_array_get_idx(struct json_object *obj,int idx);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注意：</strong>编译时要加上动态库，例如：gcc -o build main.c -ljson-c</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> JSON </tag>
            
            <tag> C语言 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sqlite3数据库</title>
      <link href="2021/06/18/SQLite/"/>
      <url>2021/06/18/SQLite/</url>
      
        <content type="html"><![CDATA[<h2 id="SQLite数据库"><a href="#SQLite数据库" class="headerlink" title="SQLite数据库"></a>SQLite数据库</h2><blockquote><p>SQLite是一种用ANSI-C编写的嵌入书关系数据库管理系统</p><p>SQLite是基于文件的，它与其他SQL数据库不同，因为与大多数其他SQL数据库不同，SQLite没有单独的服务器进程</p><p>SQLite支持SQL的很多特性，性能高，不支持存储过程，而SQL是一种查询语言，被不同的SQL数据库使用，它本身不是数据库</p></blockquote><p>SQLite最初设计于2000年8月。最初命名为SQLite，是因为它于SQL Server或Oracle等其他数据库管理系统不同，非常小（小于500Kb大小）</p><ul><li><strong>SQLite是完全免费的：</strong>SQLite是开源的，不需要许可证</li><li><strong>SQLite是无服务器的：</strong>SQLite不需要不同的服务器或系统来运行</li><li><strong>SQLite非常灵活</strong>：可以在一个会话中同时处理多个数据库，SQLite不需要配置，无需设置或管理</li><li><strong>SQLite是一个跨平台的DBMS：</strong>不需要Windows、Mac OS、Linux和Unix这样的大量不同平台。它可以用于许多嵌入书操作系统</li><li><strong>存储数据：</strong>SQLite提供了一种高效的数据存储方式</li><li><strong>列的可变长度：</strong>列的长度是可变的</li><li><strong>提供大量API：</strong>SQLite为大量编程语言提供API</li></ul><blockquote><p><strong>SQLite优势</strong></p></blockquote><ul><li><strong>轻量级：</strong>轻量级数据库</li><li><strong>更好的性能：</strong>读写操作非常快</li><li><strong>无需安装：</strong>不需要安装和配置</li><li><strong>可靠：</strong>不断更新内容，在断电或崩溃的情况下几乎不会丢失任何工作</li><li><strong>便携式：</strong>可以在32位和64位操作系统以及大端和小端架构中移植</li><li><strong>无障碍：</strong>SQLite数据库可通过各种第三方工具访问</li><li><strong>降低成本和复杂性：</strong>降低了应用程序成本</li></ul><p>SQLite的缺点：用于处理中低流量的HTTP请求，大多数情况下，数据库大小限制在2GB</p><blockquote><p>SQLite命令三种类型</p></blockquote><ul><li><strong>DDL：</strong>数据定义语言create、alter、drop</li><li><strong>DML：</strong>数据操作语言insert、updata、delete</li><li><strong>DQL：</strong>数据查询语言select</li><li><strong>SQLite点命令</strong></li></ul><blockquote><p>SQLite语法</p></blockquote><ul><li><strong>区分大小写：</strong>不区分大小写，但是有些命令区分大小写；例如GLOB和glob在SQLite中具有不一样的含义</li><li><strong>注释：</strong>不能嵌套，以两个连续的“-”字符开头</li></ul><blockquote><p>SQLite数据类型</p></blockquote><ul><li>integer：带符号的整型(最多64位)</li><li>real：8字节表示的浮点类型</li><li>text：字符类型，支持多种编码（如UTF-8、UTF-16），大小无限制</li><li>blob：任意类型的数据，大小无限制。BLOB二进制大对象，使用二进制保存数据</li><li>null：表示空值</li></ul><blockquote><p>SQLite3安装</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 只下载包但是不安装，其中不包含API接口apt-get download sqlite3 # 下载并安装apt-get install sqlite3# 进入sqlite3,这样进入写的数据是在内存中，退出后数据就会消失sqlite3# 进入sqlite3，并保存在哪个位置sqlite3 student# 退出sqlite3.exit# 查看表.table# 设置查询的间隙.mode column# 设置查询的表头.header on# 创建表create table student (id integer,name text,age integer);# 如果不存在就创建表否则不创建create table if not exists student (id integer,name text,age integer);# 查看表结构.schema# 插入数据insert into student (id,name,age) values(1,&quot;aa&quot;,11);insert into student values(2,&quot;bb&quot;,22),(3,&quot;cc&quot;,33);# 查询数据select * from student;# 修改数据update student set age&#x3D;25 where id&#x3D;3;# 删除数据delete from student where id&#x3D;1;# 删除表drop table student<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><blockquote><p>SQLite的API</p></blockquote><p><a href="https://sqlite.org/cintro.html">C语言API接口函数</a></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"># 安装头文件apt-get install libsqlite3-dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; filename: 数据库的名字，如果不存在则创建&#x2F;&#x2F; ppDb：返回数据库句柄&#x2F;&#x2F; 返回值：返回SQLITE_OK表示成功int sqlite3_open(const char *filename,sqlite3 **ppDb);&#x2F;&#x2F; ppDb：表示数据库的句柄&#x2F;&#x2F; 返回值：返回错误描述字符串const char *sqlite3_errmsg(sqlite3* ppDb);    &#x2F;&#x2F; 万能函数处理指令int sqlite3_exec(    sqlite3*,&#x2F;*数据库句柄*&#x2F;    const char *sql, &#x2F;*将要执行的指令的字符串*&#x2F;    int (*callback)(void *,int,char **,char **), &#x2F;*回调函数，如果执行的指令的结果需要处理，就需要用回调函数处理，创建表就不需要回调函数*&#x2F;void *, &#x2F;*回调函数的第一个参数*&#x2F;char **errmsg &#x2F;*保存错误信息*&#x2F;);int sqlite3_get_table(    sqlite3 *db,&#x2F;*数据库句柄*&#x2F;    const char *zSql,  &#x2F;*查询语句*&#x2F;    char ***pazResult,  &#x2F;*保存结果的指针*&#x2F;    int *pnRow,        &#x2F;*行数*&#x2F;    int *pnColumn,      &#x2F;*列数*&#x2F;    char **pzErrmsg     &#x2F;*保存错误信息*&#x2F;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>pazResult存放结构 </p><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210618104412006.png" alt="image-20210618104412006"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sqlite3.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token keyword">int</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">,</span><span class="token keyword">int</span> column<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>value<span class="token punctuation">,</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>name<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>column<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s=%s "</span><span class="token punctuation">,</span>name<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>value<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">int</span> ret<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">char</span> commod<span class="token punctuation">[</span><span class="token number">128</span><span class="token punctuation">]</span><span class="token punctuation">;</span>sqlite3 <span class="token operator">*</span>ppdb<span class="token punctuation">;</span>    <span class="token comment">//打开数据库，如果不存在则创建</span>    ret<span class="token operator">=</span><span class="token function">sqlite3_open</span><span class="token punctuation">(</span><span class="token string">"student.db"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>ppdb<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">!=</span>SQLITE_OK<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span><span class="token string">"sqlite3_open error:%s"</span><span class="token punctuation">,</span><span class="token function">sqlite3_errmsg</span><span class="token punctuation">(</span>ppdb<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">//创建表，如果存在则不执行</span><span class="token function">memset</span><span class="token punctuation">(</span>commod<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>commod<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sprintf</span><span class="token punctuation">(</span>commod<span class="token punctuation">,</span><span class="token string">"create table if not exists student (id integer,name text,age integer);"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ret<span class="token operator">=</span><span class="token function">sqlite3_exec</span><span class="token punctuation">(</span>ppdb<span class="token punctuation">,</span>commod<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">!=</span>SQLITE_OK<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span><span class="token string">"sqlite3_exec error:%s"</span><span class="token punctuation">,</span><span class="token function">sqlite3_errmsg</span><span class="token punctuation">(</span>ppdb<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token comment">//插入数据</span><span class="token keyword">int</span> age<span class="token punctuation">,</span>id<span class="token punctuation">;</span><span class="token keyword">char</span> name<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入学号 姓名 年龄：\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d%s%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>id<span class="token punctuation">,</span>name<span class="token punctuation">,</span><span class="token operator">&amp;</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">memset</span><span class="token punctuation">(</span>commod<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>commod<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sprintf</span><span class="token punctuation">(</span>commod<span class="token punctuation">,</span><span class="token string">"insert into student values(%d,'%s',%d);"</span><span class="token punctuation">,</span>id<span class="token punctuation">,</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>ret<span class="token operator">=</span><span class="token function">sqlite3_exec</span><span class="token punctuation">(</span>ppdb<span class="token punctuation">,</span>commod<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">!=</span>SQLITE_OK<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span><span class="token string">"sqlite3_exec error:%s"</span><span class="token punctuation">,</span><span class="token function">sqlite3_errmsg</span><span class="token punctuation">(</span>ppdb<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>    <span class="token comment">//查询数据</span><span class="token function">memset</span><span class="token punctuation">(</span>commod<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>commod<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sprintf</span><span class="token punctuation">(</span>commod<span class="token punctuation">,</span><span class="token string">"select * from student"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ret<span class="token operator">=</span><span class="token function">sqlite3_exec</span><span class="token punctuation">(</span>ppdb<span class="token punctuation">,</span>commod<span class="token punctuation">,</span>print<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">!=</span>SQLITE_OK<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span><span class="token string">"sqlite3_exec error:%s"</span><span class="token punctuation">,</span><span class="token function">sqlite3_errmsg</span><span class="token punctuation">(</span>ppdb<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>    <span class="token comment">//查询数据</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>pazresult<span class="token punctuation">;</span><span class="token keyword">int</span> row<span class="token punctuation">;</span><span class="token keyword">int</span> column<span class="token punctuation">;</span><span class="token function">memset</span><span class="token punctuation">(</span>commod<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>commod<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">sprintf</span><span class="token punctuation">(</span>commod<span class="token punctuation">,</span><span class="token string">"select * from student"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ret<span class="token operator">=</span><span class="token function">sqlite3_get_table</span><span class="token punctuation">(</span>ppdb<span class="token punctuation">,</span>commod<span class="token punctuation">,</span><span class="token operator">&amp;</span>pazresult<span class="token punctuation">,</span><span class="token operator">&amp;</span>row<span class="token punctuation">,</span><span class="token operator">&amp;</span>column<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>ret<span class="token operator">!=</span>SQLITE_OK<span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span><span class="token string">"sqlite3_get_table error:%s"</span><span class="token punctuation">,</span><span class="token function">sqlite3_errmsg</span><span class="token punctuation">(</span>ppdb<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> index<span class="token operator">=</span>column<span class="token punctuation">;</span>    <span class="token comment">// row不包含第一行，也就是说当row=50时就表示一共有50行数据</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>row<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>column<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s=%s "</span><span class="token punctuation">,</span>pazresult<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>pazresult<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>注意编译时要加上动态库，例如gcc -o build main.c -lsqlite3</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++异常处理</title>
      <link href="2021/06/05/C++%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>2021/06/05/C++%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="C-异常处理"><a href="#C-异常处理" class="headerlink" title="C++异常处理"></a>C++异常处理</h3><blockquote><p>异常处理是编程语言或计算机硬件里的一种机制，用于处理软件或信息系统中出现的异常状况</p></blockquote><blockquote><p>异常处理的目的：通过异常处理，我们可以对用户在程序中的非法操作进行控制和提示，以防程序崩溃；但是异常处理没有普通方法调用速度快，过度的错误处理会影响应用程序运行的效率</p></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;void func(float a,float b,float &amp;c)&#123;    c&#x3D;a&#x2F;b;&#125;int main() &#123;    float a&#x3D;10,b&#x3D;0,c&#x3D;0;    func(a,b,c);    cout&lt;&lt;&quot;hello world&quot;&lt;&lt;endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210605152723693.png" alt="image-20210605152723693"></p><blockquote><p><strong>注意</strong>：b是float类型，不是一个精确值，是一个接近0的近似值，所以程序并没有中断</p></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;void func(float a,float b,float &amp;c)&#123;    if(b&gt;-0.00001&amp;&amp;b&lt;0.00001)&#123;        return ;    &#125;    c&#x3D;a&#x2F;b;&#125;int main() &#123;    float a&#x3D;10,b&#x3D;0,c&#x3D;0;    func(a,b,c);    cout&lt;&lt;&quot;hello world&quot;&lt;&lt;endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="C-异常处理方式"><a href="#C-异常处理方式" class="headerlink" title="C++异常处理方式"></a>C++异常处理方式</h3><blockquote><p>C++异常处理主要使用三个关键字：try、throw和catch</p></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">try&#123;    包含可能抛出异常的语句;&#125;catch(类型名[形参名])&#123;    处理异常的语句;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>满足某个条件时显式抛出一个异常</li><li>使用catch块来匹配抛出的异常类型</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;void func(float a,float b,float &amp;c)&#123;    &#x2F;&#x2F; 显式抛出异常    if(b&gt;-0.00001&amp;&amp;b&lt;0.00001)        throw &quot;error b&#x3D;0&quot;;    c&#x3D;a&#x2F;b;&#125;int main() &#123;    float a&#x3D;10,b&#x3D;0,c&#x3D;0;    try&#123;        func(a,b,c);    &#125;catch(const char *error)&#123;        cout&lt;&lt;error&lt;&lt;endl;    &#125;catch(int error)&#123;        cout&lt;&lt;error&lt;&lt;endl;    &#125;catch(...)&#123;        cout&lt;&lt;&quot;可以捕获任何一个异常&quot;&lt;&lt;endl;    &#125;    &#x2F;&#x2F; 按照顺序捕获异常，匹配了之后就不会再向下匹配    &#x2F;&#x2F; 一般匹配程度高的catch块放在前面，而...的catch块是“保底”的，防止有些异常没有匹配到catch块，通用性最强但是针对性最差，所以应该放在所有catch块的后面    printf(&quot;hello world&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210605155015241.png" alt="image-20210605155015241"></p><blockquote><p>异常处理执行顺序：抛出异常、捕获异常、处理异常</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归问题</title>
      <link href="2021/05/31/%E9%80%92%E5%BD%92%E9%97%AE%E9%A2%98/"/>
      <url>2021/05/31/%E9%80%92%E5%BD%92%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="全排序"><a href="#全排序" class="headerlink" title="全排序"></a>全排序</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 给定一个数组，打印出这个数组所有的组合void DSF(int num[],int n,vector&lt;int&gt; &amp;v,bool key[])&#123;    if(v.size()&gt;&#x3D;n)&#123;        for_each(v.begin(),v.end(),[](int n)&#123;            printf(&quot;%d&quot;,n);        &#125;);        printf(&quot; &quot;);        return ;    &#125;    for(int i&#x3D;0;i&lt;n;i++)&#123;        if(!key[i])            continue;        v.push_back(num[i]);        key[i]&#x3D;false;        DSF(num,n,v,key);        v.pop_back();        key[i]&#x3D;true;    &#125;&#125;void sortAll(int num[],int n)&#123;    if(num&#x3D;&#x3D;nullptr||n&lt;&#x3D;0)&#123;        return ;    &#125;    vector&lt;int&gt; v;    bool key[n];    for(int i&#x3D;0;i&lt;n;i++)&#123;        key[i]&#x3D;true;    &#125;    DSF(num,n,v,key);&#125;int main()&#123;    int num[]&#x3D;&#123;1,5,6,7,2&#125;;    sortAll(num,sizeof(num)&#x2F;sizeof(int));    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210531213603591.png" alt="image-20210531213603591"></p><hr><h2 id="素数环"><a href="#素数环" class="headerlink" title="素数环"></a>素数环</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 给定一个数组判断，如果通过这个数组的值组成的环，相邻两个元素相加都是素数，则是素数环，则返回true，否则返回falsebool prime(int num[],int n,vector&lt;int&gt; &amp;v,bool key[],bool value[])&#123;    if(v.size()&gt;&#x3D;n)&#123;        int temp&#x3D;v.back();        if(value[temp+num[0]]&#x3D;&#x3D;true)&#123;            for_each(v.begin(),v.end(),[](int n)&#123;                printf(&quot;%d &quot;,n);            &#125;);            printf(&quot;\n&quot;);            return true;        &#125;        return false;    &#125;    for(int i&#x3D;1;i&lt;n;i++)&#123;        if(key[i]&#x3D;&#x3D;false)            continue;        int temp&#x3D;v.back();        if(value[temp+num[i]]&#x3D;&#x3D;true)&#123;            v.push_back(num[i]);            key[i]&#x3D;false;            if(prime(num,n,v,key,value)&#x3D;&#x3D;true)&#123;                return true;            &#125;            v.pop_back();            key[i]&#x3D;true;        &#125;    &#125;    return false;&#125;bool ring(int num[],int n)&#123;    if(num&#x3D;&#x3D;nullptr||n&lt;&#x3D;0)&#123;        return false;    &#125;    int primenumber[]&#x3D;&#123;2,3,5,7,11,13,17,19,23,29,31,37,41,43,53,59,61,67,71,73,79,83,89,97&#125;;    bool value[100];    int j&#x3D;0;    for(int i&#x3D;0;i&lt;100;i++)&#123;        if(i&#x3D;&#x3D;primenumber[j])&#123;            value[i]&#x3D;true;            j++;            continue;        &#125;        value[i]&#x3D;false;    &#125;    vector&lt;int&gt; v;    bool key[n];    for(int i&#x3D;0;i&lt;n;i++)&#123;        key[i]&#x3D;true;    &#125;    v.push_back(num[0]);    key[0]&#x3D;false;    return prime(num,n,v,key,value);&#125;int main()&#123;    int num[]&#x3D;&#123;1,2,2,3&#125;;    bool key&#x3D;false;    key&#x3D;ring(num,sizeof(num)&#x2F;sizeof(int));    if(key)&#123;        cout&lt;&lt;&quot;ok&quot;&lt;&lt;endl;    &#125;else&#123;        cout&lt;&lt;&quot;false&quot;&lt;&lt;endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210531214216191.png" alt="image-20210531214216191"></p><hr><h2 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; sum表示有多少可行的占位&#x2F;&#x2F; num数组的下标代表的是行数，值代表的是列数，例如num[3]&#x3D;6;代表的是第四行的皇后占的是第七个位置&#x2F;&#x2F; num数组只要保证8个行中分布都是0~7之间的数字并且不重复，就可以确保皇后不会在行或者列上冲突int sum&#x3D;0;bool eightqueen(int num[],bool key[],int index)&#123;    if(index&#x3D;&#x3D;8)&#123;        for(int i&#x3D;0;i&lt;8;i++)&#123;            if(key[i]&#x3D;&#x3D;true)&#123;                key[i]&#x3D;false;                num[index-1]&#x3D;i;                for(int j&#x3D;0;j&lt;index-1;j++)&#123;                    if(index-1-j&#x3D;&#x3D;num[index-1]-num[j]||index-1-j&#x3D;&#x3D;num[j]-num[index-1])&#123;                        key[i]&#x3D;true;                        return false;                    &#125;                &#125;                key[i]&#x3D;true;                sum++;                for(int j&#x3D;0;j&lt;index;j++)&#123;                    cout&lt;&lt;num[j]&lt;&lt;&quot; &quot;;                &#125;                cout&lt;&lt;endl;                return true;            &#125;        &#125;        return false;    &#125;    for(int i&#x3D;0;i&lt;8;i++)&#123;        if(key[i]&#x3D;&#x3D;false)&#123;            continue;        &#125;        key[i]&#x3D;false;        num[index-1]&#x3D;i;        bool check&#x3D;true;        for(int j&#x3D;0;j&lt;index-1;j++)&#123;            if(index-1-j&#x3D;&#x3D;num[index-1]-num[j]||index-1-j&#x3D;&#x3D;num[j]-num[index-1])&#123;                check&#x3D;false;                break;            &#125;        &#125;        if(check&#x3D;&#x3D;true)            eightqueen(num,key,index+1);        key[i]&#x3D;true;    &#125;    return false;&#125;bool eightqu(void)&#123;    int num[8];    bool key[8];    for(int i&#x3D;0;i&lt;8;i++)&#123;        key[i]&#x3D;true;        num[i]&#x3D;0;    &#125;    return eightqueen(num,key,1);&#125;int main()&#123;    eightqu();    cout&lt;&lt;sum&lt;&lt;endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210531214818277.png" alt="image-20210531214818277"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++流</title>
      <link href="2021/05/29/C++%20%E6%B5%81/"/>
      <url>2021/05/29/C++%20%E6%B5%81/</url>
      
        <content type="html"><![CDATA[<h2 id="C-输入输出流概述"><a href="#C-输入输出流概述" class="headerlink" title="C++输入输出流概述"></a>C++输入输出流概述</h2><blockquote><p><strong>流</strong>是有方向的字节序列</p></blockquote><ul><li><p>流向内存的数据称为输入流</p></li><li><p>流出内存的数据称为输出流</p></li></ul><blockquote><p><strong>流</strong>类</p></blockquote><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210529162855302.png" alt="image-20210529162855302"></p><p>ios类及其派生类：输入和输出</p><table><thead><tr><th>流实体</th><th>cin</th><th>cout</th><th>cerr</th><th>clog</th></tr></thead><tbody><tr><td>所属类</td><td>istream</td><td>ostream</td><td>ostream</td><td>ostream</td></tr><tr><td>说明</td><td>标准输入流实体</td><td>标准输出流实体</td><td>标准错误输出流实体</td><td>标准错误输出流实体</td></tr><tr><td>源/目标</td><td>键盘</td><td>显示器，可以重定向到文件</td><td>显示器</td><td>显示器</td></tr><tr><td>能否缓冲</td><td>不能</td><td>默认不使用，可以使用stdout缓冲区</td><td>不能</td><td>默认不使用，可以使用stderr缓冲区</td></tr></tbody></table><h2 id="ostream类"><a href="#ostream类" class="headerlink" title="ostream类"></a>ostream类</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 运算符&lt;&lt;重载ostream &amp; operator&lt;&lt;(int n);ostream &amp; operator&lt;&lt;(double d);ostream &amp; operator&lt;&lt;(char ch);...&#x2F;&#x2F; &lt;&lt;输出运算支持拼接输出cout&lt;&lt; &quot;hello&quot; &lt;&lt; &quot;world&quot; &lt;&lt;endl; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; put方法&#x2F;&#x2F; 把一个字符写道输出流中ostream &amp; put(char ch); &#x2F;&#x2F; cout.put(&#39;x&#39;);&#x2F;&#x2F; cout.put(&#39;a&#39;).put(&#39;b&#39;).put(&#39;c&#39;);&#x2F;&#x2F; write方法&#x2F;&#x2F; 从buffer指向的内存空间取出n个字节，输出到输出流中ostream &amp; write(char *buffer,int n); &#x2F;&#x2F; char *buf&#x3D;&quot;acd&quot;; &#x2F;&#x2F; cout.write(buf,2).write(buf,1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="istream类"><a href="#istream类" class="headerlink" title="istream类"></a>istream类</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 运算符&gt;&gt;重载istream &amp; operator&gt;&gt;(int &amp;val); &#x2F;&#x2F; cin&gt;&gt;10; 错误istream &amp; operator&gt;&gt;(double &amp;val); istream &amp; operator&gt;&gt;(char &amp;val);&#x2F;&#x2F; 输入运算支持拼接输入 cin&gt;&gt;a&gt;&gt;b;&#x2F;&#x2F; cin&gt;&gt;接受数字和字符串，遇到空格、tab、回车结束<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char a[10];char b[10];cin&gt;&gt;a;cout&lt;&lt;&quot;a:&quot;&lt;&lt;a&lt;&lt;endl;cin&gt;&gt;b;cout&lt;&lt;&quot;b:&quot;&lt;&lt;b&lt;&lt;endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210529165608991.png" alt="image-20210529165608991"></p><hr><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; get方法&#x2F;&#x2F; get可以接受空格和制表符，只把回车符作为终止符，而&gt;&gt;将空格、制表符和回车符都作为终止符char get(); &#x2F;&#x2F;从输入流实体中提取一个字符，作为返回值，该返回值可以是空格也可以是制表符也可以是回车符istream &amp; get(char &amp;ch); &#x2F;&#x2F;从输入流实体中提取一个字符，作为返回值，该返回值可以是空格也可以是制表符也可以是回车符istream &amp; get(char *buffer,int n,char ch&#x3D;&#39;\n&#39;); &#x2F;&#x2F;从输入流实体中读取n-1个字符，或者遇到第三个参数指定的终止符，并补上&#39;\0&#39;字符，存放在buffer指针指向的内存空间中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char a[10];char b[10];cin.get(a,10);cout&lt;&lt;&quot;a:&quot;&lt;&lt;a&lt;&lt;endl;cin.get(b,10);cout&lt;&lt;&quot;b:&quot;&lt;&lt;b&lt;&lt;endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210529171254158.png" alt="image-20210529171254158"></p><blockquote><p><strong>注意</strong>：get遇到回车符终止，在输入的时候输入回车符终止，该回车符依然在输入缓冲区，当第二个输入get遇到了回车符直接终止了并没有等待输入，所以b里面就只有一个’\0’</p></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char a[10];char b[10];cin.get(a,10).get();cout&lt;&lt;&quot;a:&quot;&lt;&lt;a&lt;&lt;endl;cin.get(b,10).get();cout&lt;&lt;&quot;b:&quot;&lt;&lt;b&lt;&lt;endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210529171706787.png" alt="image-20210529171706787"></p><blockquote><p><strong>注意</strong>：get()接收了回车符，以至于第二个get(b,10)没有遇到回车符，可以正常的等待用户输入，运行正常</p></blockquote><hr><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; getline方法istream &amp; getline(char *buffer,int n,char ch&#x3D;&#39;\n&#39;);&#x2F;&#x2F; 功能与get类似，从输入流实体中读取n-1个字符和1个&#39;\0&#39;字符，可以接受空格和制表符，只把回车符作为终止符，但在完成读取数据后，从读取的数据中删除该终止符char a[10];char b[10];cin.getline(a,10);cout&lt;&lt;&quot;a:&quot;&lt;&lt;a&lt;&lt;endl;cin.getline(b,10);cout&lt;&lt;&quot;b:&quot;&lt;&lt;b&lt;&lt;endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210529185235148.png" alt="image-20210529185235148"></p><blockquote><p><strong>注意</strong>：cin.get(buffer,size)读取数据到buffer中，遇到’\n’结束，下一次的cin.get(buffer,size)遇到’\n’直接结束了读取，读到了空字符串；可以使用cin.get(buffer,size).get()，抛弃’\n’</p><p>cin.getline()每次读取一整行并抛弃’\n’</p></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; read方法istream &amp; read(char *buffer,int n);&#x2F;&#x2F; 从输入流中读取n个字符，保存到buffer指向的内存空间中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注意</strong>：read和get、getline区别</p></blockquote><ul><li>n个而非n-1个输入流中的字符，没有额外补’\0’;</li><li>‘\n’、空格、’\t’都会被当作有效字符读入；</li><li>必须读进n个字符，如果输入字符不够，则会等待输入；</li><li>不构成字符串，不能使用cout&lt;&lt;buffer输出，只能使用cout.write(buffer,n)输出</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char a[10];char b[10];cin.read(a,10);cout.write(a,10);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210529190607019.png" alt="image-20210529190607019"></p><h2 id="C-输入输出总结"><a href="#C-输入输出总结" class="headerlink" title="C++输入输出总结"></a>C++输入输出总结</h2><ol><li>不涉及空格、tab、回车字符串的输入以及所有的数字输入用&gt;&gt;</li><li>输入一个字符的时候可以用&gt;&gt;或者用get方法</li><li>输入一行字符的时候用get、getline或者read方法</li><li>输出用&lt;&lt;或者write</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++多态</title>
      <link href="2021/05/22/C++%E5%A4%9A%E6%80%81/"/>
      <url>2021/05/22/C++%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h2 id="C-多态"><a href="#C-多态" class="headerlink" title="C++多态"></a>C++多态</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class Wood&#123;protected:    int height;    int cost;public:    Wood(int height,int cost)    &#123;        this-&gt;height&#x3D;height;        this-&gt;cost&#x3D;cost;    &#125;    virtual void show()    &#123;        cout&lt;&lt;height&lt;&lt;endl;    &#125;&#125;;class Table:public Wood&#123;public:    Table(int height,int cost): Wood(height,cost)&#123;&#125;    void show()    &#123;        cout&lt;&lt;&quot;Table:&quot;&lt;&lt;height&lt;&lt;endl;    &#125;&#125;;int main()&#123;    Table t1(55,61);Wood *ptr&#x3D;&amp;t1;    ptr-&gt;show(); &#x2F;&#x2F; Table:55    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/2021-5-22-15-53.png" alt="2021-5-22-15-53"></p><ul><li>当类中出现了虚函数，该类中就会生成一个虚函数指针，该虚函数指针指向虚函数表，虚函数表实质上来说是一个数组</li><li>当基类中有虚函数时，派生类中也会生成一个虚函数指针，指向虚函数表，这个表继承了基类虚函数表的元素</li><li>如果重写虚函数就会修改虚函数表的内容，让其指向自己的函数</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class Wood&#123;public:    Wood(int height,int cost)    &#123;        this-&gt;height&#x3D;height;        this-&gt;cost&#x3D;cost;    &#125;    virtual void show()    &#123;&#x2F;&#x2F;        cout&lt;&lt;height&lt;&lt;endl;        cout&lt;&lt;&quot;hell&quot;&lt;&lt;endl;    &#125;protected:    int height;    int cost;&#125;;class Table:public Wood&#123;public:    Table(int height,int cost): Wood(height,cost)&#123;&#125;    void show()    &#123;        cout&lt;&lt;&quot;Table:&quot;&lt;&lt;height&lt;&lt;endl;    &#125;&#125;;typedef void (*Myfunc)();int main()&#123;    Wood w1(12,36);    Table t1(55,61);    long long *wptr&#x3D;(long long *)(((long long *)(*((long long *)&amp;w1)))[0]);    long long *tptr&#x3D;(long long *)(((long long *)(*((long long *)&amp;t1)))[0]);    Myfunc ptr&#x3D;(Myfunc)wptr;    ptr(); &#x2F;&#x2F; hell    cout&lt;&lt;wptr&lt;&lt;endl; &#x2F;&#x2F;0x402d80    cout&lt;&lt;tptr&lt;&lt;endl; &#x2F;&#x2F;0x402e40    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ lamdba表达式</title>
      <link href="2021/05/22/C++lamdba%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>2021/05/22/C++lamdba%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="C-lamdba表达式"><a href="#C-lamdba表达式" class="headerlink" title="C++ lamdba表达式"></a>C++ lamdba表达式</h2><blockquote><p><strong>lamdba表达式</strong></p></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; lamdab表达式语法[捕获列表](参数列表) mutable(可选) 异常属性 -&gt; 返回类型&#123;    &#x2F;&#x2F; 函数体&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="lamdab表达式基本语法"><a href="#lamdab表达式基本语法" class="headerlink" title="lamdab表达式基本语法"></a>lamdab表达式基本语法</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; lamdba表达式可以看作是匿名函数&#x2F;&#x2F; 捕获列表 参数列表 -&gt; 返回值类型[](int i,int j) -&gt; int&#123;    &#x2F;&#x2F; 函数体    return i*j;&#125;&#x2F;&#x2F; lamdba表达式调用int k&#x3D;[](int i,int j) -&gt; int&#123;    return i*j;&#125;(1,2);&#x2F;&#x2F; lamdba表达式存储auto f1&#x3D;[](int i,int j) -&gt; int&#123;    return i*j;&#125;;f1(1,2);&#x2F;&#x2F; lamdba表达式嵌套&#x2F;&#x2F; 如果不写lamdba表达式返回类型，编译器会自动推导[](int i)&#123;    return [i](int j)&#123;        return i*j;    &#125;(10);&#125;(20);&#x2F;&#x2F; lambda表达式嵌套存储auto f&#x3D;[](int i)&#123;    return [i](int j)&#123;        return i*j;    &#125;;&#125;;f(1)(2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="lamdba表达式参数捕获"><a href="#lamdba表达式参数捕获" class="headerlink" title="lamdba表达式参数捕获"></a>lamdba表达式参数捕获</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int i&#x3D;2;&#x2F;&#x2F; 按值捕获 不会修改外部的变量&#x2F;&#x2F; 想要修改按值捕获的值要加上mutable关键字&#x2F;&#x2F;加上 mutable 修饰符后，可以修改传递进来的拷贝（注意是能修改拷贝，而不是值本身）。exception 声明用于指定函数抛出的异常，如抛出整数类型的异常，可以使用 throw(int)auto f&#x3D;[i]() mutable&#123;    return ++i;&#125;;cout&lt;&lt;f()&lt;&lt;endl; &#x2F;&#x2F; 3cout&lt;&lt;f()&lt;&lt;endl; &#x2F;&#x2F; 4cout&lt;&lt;f()&lt;&lt;endl; &#x2F;&#x2F; 5cout&lt;&lt;i&lt;&lt;endl; &#x2F;&#x2F;2&#x2F;&#x2F; 当使用mutable按值捕获时，每次都使用声明的时候的拷贝<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int i&#x3D;1;&#x2F;&#x2F; 按值捕获时捕获的是声明匿名函数时，捕获列表参数的值 auto f&#x3D;[i]()&#123;    std::cout&lt;&lt;i&lt;&lt;std::endl;&#125;;i&#x3D;2;f(); &#x2F;&#x2F; 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 引用捕获 会修改外部的值 外部修改也会影响内部int i&#x3D;1;auto f&#x3D;[&amp;i]()&#123;    std::cout&lt;&lt;i&lt;&lt;std::endl;    i&#x3D;2;&#125;;i&#x3D;3;f(); &#x2F;&#x2F; 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">&#x2F;&#x2F; 捕获列表int i&#x3D;1;int j&#x3D;2;int k&#x3D;3;int m&#x3D;4;&#x2F;&#x2F; 按值捕获所有变量[&#x3D;]()&#123;    &#x2F;&#x2F; 函数体&#125;;&#x2F;&#x2F; 按引用捕获所有变量[&amp;]()&#123;    &#x2F;&#x2F; 函数体&#125;;&#x2F;&#x2F; 引用和值捕获[i,j,&amp;k,&amp;m]()&#123;    &#x2F;&#x2F; 函数体&#125;; &#x2F;&#x2F; &#x3D;，&amp;a，&amp;b:除 a 和 b 按引用进行传递外，其他参数都按值进行传递&#x2F;&#x2F; &amp;，a，b:除 a 和 b 按值进行传递外，其他参数都按引用进行传递<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="lamdba表达式应用"><a href="#lamdba表达式应用" class="headerlink" title="lamdba表达式应用"></a>lamdba表达式应用</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; v&#x3D;&#123;1,2,3,4,5,6,7,8,9&#125;;for_each(v.begin(),v.end(),[](int n)&#123;    cout &lt;&lt; n &lt;&lt;endl;&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>散列表</title>
      <link href="2021/05/18/%E6%95%A3%E5%88%97%E8%A1%A8/"/>
      <url>2021/05/18/%E6%95%A3%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p><strong>散列（Hash Table）表</strong>又称哈希表，这种数据结构的特点是：数据元素的关键字和它在表中的存储地址直接相关。关键字与存储地址对应的关系的函数称为<strong>哈希函数</strong></p><p><strong>哈希函数</strong>：Address=Hash(key)</p><ol><li>哈希是一种以常数平均时间执行插入、删除和查找的技术，但是，不支持元素排序和查找最小(大)值的操作</li><li>哈希函数是一种映射关系，很灵活，任何关键字通过它的计算，返回的值都落在表长允许的范围之内即可</li><li>对于不同的关键字，可能得到相同的哈希地址，这种现象称为<strong>冲突</strong>；哈希地址相同的关键字称为<strong>同义词</strong></li><li>处理冲突的方法有四种：链地址法、开放定址法、再散列表和建立公共溢出区</li><li>哈希表的<strong>装填因子</strong>（表中记录数/表长）越大，关键字<strong>冲突</strong>的可能性越大，<strong>同义词</strong>越多，查找效率可能更低<img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210518155948084.png" alt="image-20210518155948084" style="zoom: 50%;"><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210518160152256.png" alt="image-20210518160152256" style="zoom: 50%;"></li></ol><h2 id="散列函数设计"><a href="#散列函数设计" class="headerlink" title="散列函数设计"></a>散列函数设计</h2><blockquote><p><strong>除留余数法</strong>：Hash(key)=key%p</p></blockquote><ol><li>如果散列表的表长为m，p为小于等于m的最大质数，再一般情况下，对质数取余会让冲突更少，数据元素在散列表的分布更均匀</li><li>质数又称素数，除了1和自身，不能被其它自然数整除的数(1,3,7,13,17,19…….)<img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210518161149100.png" alt="image-20210518161149100" style="zoom: 67%;"></li></ol><blockquote><p><strong>直接定址法</strong>：Hash(key)=a*key+b，a和b为常数</p></blockquote><ul><li>这种方法的计算简单，不会产生冲突，适合关键字的分布比较连续的情况，如果关键字分布不连续，空位较多，则会造成存储空间的浪费</li></ul><blockquote><p><strong>数字分析法</strong></p></blockquote><ul><li>根据关键字的特点，从数值中截取分布比较均匀的若干位作为散列地址，在应用开发中，还要结合除留余数法一起使用</li></ul><blockquote><p><strong>平方取中法</strong></p></blockquote><ul><li>根据关键字的特点，取关键字的平方值的中间若干位作为散列地址。这种方法得到的散列表地址和关键字的每个位都有关系，适用于关键字的取值不够均匀或小于散列地址所需的位数</li></ul><blockquote><p><strong>随机数法</strong></p></blockquote><ul><li>选择一个随机函数，用关键字作为随机函数的种子，返回值位散列地址，即Hash(key)=radmom(key)，可结合除留余数法一起使用</li></ul><blockquote><p>散列函数的设计原则</p></blockquote><ol><li>清除关键字分布情况</li><li>散列表的大小要合理，太大浪费空间，太小则会产生太多的同义词</li><li>散列表中的数据分布要均匀，不要形成堆积（聚集）</li><li>散列函数代码要精简</li></ol><h2 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h2><blockquote><p><strong>开放定址法</strong></p></blockquote><ul><li>如果有冲突发生，那么就尝试其他的存储单元，直到找出空的单元为止</li><li>H<sub>i</sub>=(Hash(key)+d<sub>i</sub>)%m i=0,1,2,3,4,…,m-1，Hash(key)为散列函数，m为散列表长，d<sub>i</sub>为增量序列(i为第i次发生冲突，0表示没冲突)，有三种取法：<ol><li>线性探测法，d<sub>i</sub>=0,1,2,3,4,……,m-1</li><li>平方探测法，d<sub>i</sub>=0<sup>2</sup>,1<sup>2</sup>,-1<sup>2</sup>,2<sup>2</sup>,-2<sup>2</sup>,3<sup>2</sup>,-3<sup>2</sup>,……,k<sup>2</sup>,-k<sup>2</sup>(k&lt;=m/2)</li><li>伪随机序列法，d<sub>i</sub>是一个伪随机的序列，如0,3,-2,5,7,-5,-7,9……</li></ol></li></ul><h2 id="再散列"><a href="#再散列" class="headerlink" title="再散列"></a>再散列</h2><p>准备多几个散列函数，如果发生了冲突，就用下一个散列函数计算一个新的地址，直到不冲突为止</p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="2021/05/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>2021/05/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="动态规划特点"><a href="#动态规划特点" class="headerlink" title="动态规划特点"></a>动态规划特点</h3><ol><li>计数<ul><li>有多少种方式走到右下角</li><li>有多少种方式选出k个数使得和是sum</li></ul></li><li>求最大最小值<ul><li>从左上角走到右下角路径的最大数字和</li><li>最长上升子序列长度</li></ul></li><li>求存在性<ul><li>取石子游戏，先手是否必胜</li><li>能不能选出k个数使得和是sum</li></ul></li></ol><h3 id="动态规划组成部分"><a href="#动态规划组成部分" class="headerlink" title="动态规划组成部分"></a>动态规划组成部分</h3><ol><li>确定状态<ul><li>最后一步（最优策略种使用的最后一枚硬币a<sub>k</sub>）</li><li>化为子问题（最少的策略拼出最小的的面值27-a<sub>k</sub>）</li></ul></li><li>转移方程<ul><li>f[X]=min{f[X-2]+1,f[X-5]+1,f[X-7]+1}</li></ul></li><li>初始化条件和边界情况<ul><li>f[0]=0，如果不能拼出Y，f[Y]=正无穷</li></ul></li><li>计算顺序<ul><li>f[0],f[1],f[2]…</li></ul></li><li>消除冗余，加速计算</li></ol><h2 id="动态规划实例"><a href="#动态规划实例" class="headerlink" title="动态规划实例"></a>动态规划实例</h2><h3 id="求最大最小值动态规划"><a href="#求最大最小值动态规划" class="headerlink" title="求最大最小值动态规划"></a>求最大最小值动态规划</h3><ol><li>你有三种硬币，分别面值2元，5元和7元，每种硬币都有足够多</li><li>买一本书需要27元</li><li>如何用最少的硬币组合正好付清，不需要对方找钱</li></ol><blockquote><p>动态规划组成部分一：<strong>确定状态</strong></p></blockquote><p><strong>确定状态</strong>需要两个意识：</p><ol><li>最后一步<ul><li>关键点1：我们不关心前面的k-1枚硬币是怎么拼出27-a<sub>k</sub>的，而且我们现在甚至不知道a<sub>k</sub>和k，但是我们可以确定前面的硬币拼出了27-a<sub>k</sub></li><li>关键点2：因为是最优策略，所以拼出27-a<sub>k</sub>的硬币数一定要最少，否则就不是最优策略<img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210516211949412.png" alt="image-20210516211949412"></li></ul></li><li>子问题<ul><li>所以我们要求：最少用多少枚硬币可以拼出27-a<sub>k</sub></li><li>原问题是最少用多少枚硬币拼出27</li><li>我们将原问题转化成一个子问题，而且规模最小：27-a<sub>k</sub></li><li>为了简化定义，我们设定状态f(X)=最少用多少枚硬币拼出X</li><li>最后一枚硬币只可能是2，5或者7</li><li>f(27)=min{f(27-2)+1,f(27-5)+1,f(27-7)+1}<img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210516212817288.png" alt="image-20210516212817288"></li></ul></li></ol><blockquote><p>动态规划组成部分二：转移方程</p></blockquote><ul><li>设状态f[X]=最少用多少枚硬币拼出X</li><li>对于任意X，f[X]=min{f[X-2]+1,f{X-5}+1,f[X-7]+1}</li></ul><blockquote><p>动态规划组成部分三：初始条件和边界情况</p></blockquote><ol><li><p>f[X]=min{f[X-2]+1,f[X-5]+1,f[X-7]+1}</p></li><li><p>两个问题：X-2，X-5或者X-7小于0怎么办？什么时候停下来？</p></li><li><p>如果不能拼出Y，就定义f[Y]=正无穷</p></li><li><p>所以f[1]=min{f[-1]+1,f[-4]+1,f[-6]+1}=正无穷，表示拼出来1</p></li><li><p>初始条件：f[0]=0 (用转移方程算不出来，需要手工定义)</p></li></ol><blockquote><p>动态规划组成部分四：计算顺序</p></blockquote><ol><li>拼出X所需要的最少硬币数：f[X]=min{f[X-2]+1,f[X-5]+1,f[X-7]+1}</li><li>初始条件：f[0]=0</li><li>然后计算f[1]，f[2]……f[27]</li><li>当我们计算到f[X]时，f[X-2]，f[X-5]，f[X-7]都已经得到结果了<img src="../../AppData/Roaming/Typora/typora-user-images/image-20210516215043727.png" alt="image-20210516215043727"></li></ol><blockquote><p><strong>结论</strong></p></blockquote><ul><li>每一步尝试三种硬币，一共27步</li><li>与递归算法相比，没有任何重复计算</li><li>算法时间复杂度（即需要进行的步数）：27*3，大于递归时间复杂度：&gt;&gt; 27*3</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// num表示硬币有哪些面值，n表示num数组的大小，cost表示总共需要多少钱</span><span class="token keyword">int</span> <span class="token function">pingyingbi</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>num<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> cost<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> f<span class="token punctuation">[</span>cost<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 求出当前操作系统int能取的正数最大值</span>    <span class="token keyword">int</span> MAXNUM<span class="token operator">=</span><span class="token punctuation">(</span><span class="token operator">~</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token punctuation">(</span><span class="token operator">~</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">8</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>cost<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>MAXNUM<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">-</span>num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">>=</span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span>num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">&lt;=</span>MAXNUM<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>f<span class="token punctuation">[</span>i<span class="token operator">-</span>num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>f<span class="token punctuation">[</span>i<span class="token operator">-</span>num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>cost<span class="token punctuation">]</span><span class="token operator">==</span>MAXNUM<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> f<span class="token punctuation">[</span>cost<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="计数型动态规划"><a href="#计数型动态规划" class="headerlink" title="计数型动态规划"></a>计数型动态规划</h3><ol><li>给定m行n列的网格，有一个机器人从左上角（0,0）出发，每一步可以向下或者向右走一步</li><li>问有多少种不同的方式走到右下角<img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210517152254213.png" alt="image-20210517152254213"></li></ol><blockquote><p>动态规划组成部分一：确定状态</p></blockquote><ol><li>最后一步：无论机器人用何种方式到达右下角，总有最后挪动的一一步：向右或者向下</li><li>右下角坐标设为(m-1，n-1)</li><li>那么前一步机器人一定是在(m-2,n-1)或者(m-1,n-2)</li></ol><blockquote><p>动态规划组成部分一：子问题</p></blockquote><ol><li>那么，如果机器人有X种方式从左上角走到(m-2，n-1)，有Y种方式从左上角走到(m-1，n-2)，则机器人有X+Y种方式走到(m-1，n-1)</li><li>问题转化为，机器人有多少种方式从左上角走到(m-2,n-1)和(m-1,n-2)</li><li>原题要求有多少种方式从左上角走到(m-1,n-1)</li><li>转化为规模更小的子问题</li><li>状态：设f[i][j]为机器人有多少种方式从左上角走到(i,j)</li></ol><blockquote><p>动态规划组成部分二：转移方程</p></blockquote><p>对于任意一个格子(i,j)，都有f[i][j]=f[i-1][j]+f[i][j-1]<img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210517153631895.png" alt="image-20210517153631895"></p><blockquote><p>动态规划组成部分三：初始条件和边界情况</p></blockquote><ul><li>初始条件：f[0][0]=1，因为机器人只有一种方式到左上角</li><li>边界情况：i=1或j=0，则前一步只能有一个方向过来f[i][j]=1</li></ul><blockquote><p>动态规划组成部分四：计算顺序</p></blockquote><ol><li>f[0][0]=1</li><li>计算第0行：f[0][0],f[0][1],…,f[0][n-1]</li><li>…</li><li>计算第m-1行：f[m-1][0],…..,f[m-1][n-1]</li><li>时间复杂度（计算步数）：O(MN)，空间复杂度（数组大小）：O(MN)</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">findwaynum</span><span class="token punctuation">(</span><span class="token keyword">int</span> m<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> map<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">==</span><span class="token number">0</span><span class="token operator">||</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                map<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                map<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>map<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>map<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> map<span class="token punctuation">[</span>m<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="存在型动态规划"><a href="#存在型动态规划" class="headerlink" title="存在型动态规划"></a>存在型动态规划</h3><ol><li>有n块石头分别在x轴的0，1，…，n-1位置</li><li>一只青蛙在石头0，想跳到石头n-1</li><li>如果青蛙在第i块石头上，它最多可以向右跳距离a<sub>i</sub></li><li>问青蛙能否跳到石头n-1</li><li>例子：输入：a=[2,3,1,1,4]，输出：true；输入：a=[3,2,1,0,4]，输出：false</li></ol><blockquote><p>动态规划组成部分一：确定状态</p></blockquote><ol><li>最后一步：如果青蛙能跳到最后一块石头n-1，我们考虑它跳的最后一步</li><li>这一步是从石头i跳过来，i&lt;n-1</li><li>这需要满足两个条件：青蛙可以跳到石头i；最后一步不超过条约的最大距离：n-1-i&lt;=a<sub>i</sub></li></ol><blockquote><p>动态规划组成部分一：子问题</p></blockquote><ol><li>那么，我们需要知道青蛙能不能跳到石头i(i&lt;n-1)</li><li>而我们原来要求青蛙能不能跳到石头n-1</li><li>变成一个规模更小的子问题了，状态：设f[j]表示青蛙能不能跳到石头j</li></ol><blockquote><p>动态规划组成部分二：转移方程</p></blockquote><ul><li>设f[j]表示青蛙能不能跳到石头j<img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210517184731890.png" alt="image-20210517184731890"></li></ul><blockquote><p>动态规划组成部分三：初始条件和边界情况</p></blockquote><ol><li>设f[j]表示青蛙能不能跳到石头j</li><li>初始条件：f[0]=true，因为青蛙一开始就在石头0</li></ol><blockquote><p>动态规划组成部分四：计算顺序</p></blockquote><ol><li>设f[j]表示青蛙能不能跳到石头j</li><li>f[j]=OR<sub>0&lt;=i&lt;j</sub>(f[i] AND i+a[i]&gt;=j)</li><li>初始化f[0]=true</li><li>计算f[1]，f[2]，…，f[n-1]</li><li>答案是f[n-1]</li><li>时间复杂度：O(N<sup>2</sup>)，空间复杂度（数组大小）：O(N)</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">true</span> <span class="token expression"><span class="token number">1</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">false</span> <span class="token expression"><span class="token number">0</span></span></span><span class="token keyword">int</span> <span class="token function">qingwatiao</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>num<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> pd<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">int</span> j<span class="token punctuation">;</span>    pd<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>true<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        pd<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>false<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>pd<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span>true<span class="token operator">&amp;&amp;</span>i<span class="token operator">-</span>j<span class="token operator">&lt;=</span>num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                pd<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>true<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> pd<span class="token punctuation">[</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 问题：给定一个整形数组，求该数组中，连续的子序列的乘积达到最大，该数组可以包含负数和0；例如[2,4,5,-1,3,0]，则输出20</span><span class="token comment">// 该函数原理动态规划</span><span class="token comment">// i的值始终大于等于j，于是pd[i][j]表示num[j]*num[j+1]* ... *num[i]</span><span class="token comment">// 所以pd[i][j]=num[j]*num[j+1]* ... *num[i]=pd[i][j+1]*num[j]</span><span class="token comment">// 初始条件当i=j时，pd[i][j]=num[i]=num[j]</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">maxmuti</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>num<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 当前max为当前操作系统下int最小的负数</span>    <span class="token keyword">int</span> max<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">8</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> pd<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>i<span class="token punctuation">;</span>j<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span>j<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                <span class="token comment">// 假设i和j的值相同时,是本身,也就是当传进来数组为[500,-2,1]时，该函数会返回500</span>                <span class="token comment">// 传进来的是[500]时，该函数会放回500</span>                pd<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>num<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>pd<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>max<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    max<span class="token operator">=</span>pd<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>                pd<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>pd<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">*</span>num<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>pd<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>max<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                    max<span class="token operator">=</span>pd<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> max<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> num<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">41</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span><span class="token function">maxmuti</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token operator">/</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>串口通信</title>
      <link href="2021/05/13/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%80%9A%E4%BF%A1/"/>
      <url>2021/05/13/%E5%B5%8C%E5%85%A5%E5%BC%8F%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="通信简介"><a href="#通信简介" class="headerlink" title="通信简介"></a>通信简介</h2><blockquote><p> 在计算机的设备与设备之间或集成电路之间常常需要进行数据传输</p></blockquote><ul><li>并行通讯：多位同时传输，例如：SDIO、FSMC</li><li>串行通讯：一位一位传输，例如：USART、I<sup>2</sup>C、SPI</li></ul><table><thead><tr><th>特性</th><th>串行通讯</th><th>并行通讯</th></tr></thead><tbody><tr><td>通讯距离</td><td>较远</td><td>较近</td></tr><tr><td>抗干扰能力</td><td>较强</td><td>较弱</td></tr><tr><td>传输速率</td><td>较慢</td><td>较快</td></tr><tr><td>成本</td><td>较低</td><td>较高</td></tr></tbody></table><ul><li>全双工：可同时收发数据</li><li>半双工：不可同时收发数据，可分时收发数据</li><li>单工：任何时刻都只能往某一个固定方向传输数据</li></ul><blockquote><p>保证数据传输的准确性：同步与异步</p><p>有时钟信号的就是同步，没有时钟信号的就是异步</p></blockquote><p>在同步通讯中，数据信号所传输的内容绝大部分就是有效数据，而异步通讯中会包含有帧的各种标识符，所以同步通讯的效率更高，但是同步通讯双方的时钟允许误差较小，而异步通讯不需要时钟</p><blockquote><p>通讯的速率</p></blockquote><ul><li>比特率：每秒钟传输的二进制的位数，单位为比特每秒</li><li>波特率：表示每秒中上传输的码元个数</li></ul><blockquote><p>码元有些时候用一个二进制位表示，在这个时候与比特率相同，但是有些时候码元用多个二进制位表示</p></blockquote><h2 id="串口通信协议"><a href="#串口通信协议" class="headerlink" title="串口通信协议"></a>串口通信协议</h2><ul><li>物理层：规定通讯系统中具有机械、电子功能部分的特性，确保原始数据在物理媒体的传输，其实就是硬件部分</li><li>协议层：协议层主要规定通讯逻辑，统一收发双方的数据打包、解压标准。其实就是软件部分</li></ul><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><blockquote><p>RS232标准</p></blockquote><p>RS232与TTL的区别主要体现在电平上，TTL电平直接从芯片或单片机或外设出来的，TTL电平高电平主要是5V或者3.3V；RS233表示1是以-15V表示，而0是用15V表示，高电平与低电平的差距非常大 </p><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210513105240821.png" alt="image-20210513105240821"></p><blockquote><p>RS232标准串口通讯结构图</p></blockquote><p>RS232标准串口高电平与低电平差距很大，容错能力非常强</p><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210513110014935.png" alt="image-20210513110014935"></p><ul><li>RS232标准串口主要用于工业设备直接通信</li><li>电平转换芯片一般有MAX3232，SP3232</li></ul><blockquote><p>DB9标准的公头及母头接法</p></blockquote><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210513110245938.png" alt="image-20210513110245938"></p><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210513110601358.png" alt="image-20210513110601358"></p><hr><blockquote><p>USB转串口通讯</p></blockquote><ul><li>USB转串口主要用于设备跟电脑通信</li><li>电平转换芯片一般有CH340、PL2303、CP2102、FT232</li><li>使用的时候电脑端需要安装电平转换芯片的驱动</li></ul><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210513110750731.png" alt="image-20210513110750731"></p><p>将TTL电平通过电平转换芯片转换为USB电平</p><blockquote><p> USB转串口线</p></blockquote><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210513114925657.png" alt="image-20210513114925657"></p><hr><blockquote><p>原生的串口到串口通讯</p></blockquote><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210513115408445.png" alt="image-20210513115408445"></p><ul><li>原生的串口通信主要是控制器跟串口的设备或者传感器通信，不需要经过电平转换芯片来转换电平，直接用TTL电平通信</li><li>GPS模块、GSM模块、串口转WIFI模块、HC04蓝牙模块都是直接就是TTL电平</li></ul><h3 id="协议层"><a href="#协议层" class="headerlink" title="协议层"></a>协议层</h3><blockquote><p>串口数据包的基本组成</p></blockquote><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210513120014820.png" alt="image-20210513120014820"></p><ul><li>起始位：由1个逻辑0的数据位表示</li><li>结束位：由0.5、1、1.5或2个逻辑1的数据位表示</li><li>有效数据：在起始位后紧接着的就是有效数据，有效数据的长度常被约定为5、6、7或8位长度</li><li>校验位：提高数据的抗干扰能力</li></ul><blockquote><p><strong>校验位</strong></p></blockquote><ul><li>奇校验：有效数据和校验位中“1”的个数为奇数</li><li>偶校验：有效数据和校验位中“1”的个数为偶数</li><li>0校验：不管有效数据中的内容是什么，校验位总为“0”</li><li>校验：不管有效数据中的内容是什么，校验位总为“1”</li><li>无校验：就是数据包中不含校验位</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 嵌入式通信原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux静态库和动态库</title>
      <link href="2021/05/09/%E5%8A%A8%E6%80%81%E5%BA%93%E4%B8%8E%E9%9D%99%E6%80%81%E5%BA%93/"/>
      <url>2021/05/09/%E5%8A%A8%E6%80%81%E5%BA%93%E4%B8%8E%E9%9D%99%E6%80%81%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux静态库与动态库"><a href="#Linux静态库与动态库" class="headerlink" title="Linux静态库与动态库"></a>Linux静态库与动态库</h2><h3 id="生成静态库"><a href="#生成静态库" class="headerlink" title="生成静态库"></a>生成静态库</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 默认生成对应的.o文件，注意c文件中不要把main函数包含进来</span>gcc <span class="token punctuation">.</span>c文件 <span class="token operator">-</span>c <span class="token comment">//例如：gcc test.c -c</span>    <span class="token comment">// 将生成的.o文件打包，静态库的名称命名规则：lib + 库的名字 + .a</span><span class="token comment">// 例如：静态库的名称可以为libtest.a、libmytest.a、libhaha.a</span>ar rcs <span class="token operator">+</span> 静态库的名称 <span class="token operator">+</span> 生成的<span class="token punctuation">.</span>o文件 <span class="token comment">// 例如：ar rcs libtest.a test.o</span>    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="使用静态库"><a href="#使用静态库" class="headerlink" title="使用静态库"></a>使用静态库</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// -L 指定静态库的目录</span><span class="token comment">// -l 指定静态库目录中的哪个静态库，指定库时不能写前缀lib，也不能写后缀名.a</span><span class="token comment">// -I 指定头文件</span><span class="token comment">// -o 自定义生成可执行文件的名字</span>gcc main<span class="token punctuation">.</span>c <span class="token operator">-</span>I include <span class="token operator">-</span>L lib <span class="token operator">-</span>l mylib <span class="token operator">-</span>o build<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="静态库的优点"><a href="#静态库的优点" class="headerlink" title="静态库的优点"></a>静态库的优点</h3><ul><li>运行程序的时候不再需要对应的库</li><li>运行程序快，因为对应的函数都被打包进了程序</li></ul><h3 id="静态库的缺点"><a href="#静态库的缺点" class="headerlink" title="静态库的缺点"></a>静态库的缺点</h3><ul><li>库被打包进程序中，导致可执行文件的大小变大</li><li>当库更新之后，要使用该库必须重新编译程序</li></ul><hr><h3 id="生成动态库"><a href="#生成动态库" class="headerlink" title="生成动态库"></a>生成动态库</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 生成与位置无关的.o</span><span class="token comment">// -I 指定头文件</span>gcc <span class="token operator">-</span>fPIC <span class="token operator">-</span>c <span class="token punctuation">.</span>c文件 <span class="token operator">-</span>I 头文件目录 <span class="token comment">// 例如：gcc -fPIC -c *.c -I include</span><span class="token comment">// 将.o打包成动态库，动态库命名规则：lib + 库文件 +.so </span>gcc <span class="token operator">-</span>shared <span class="token operator">-</span>o libmytest<span class="token punctuation">.</span>so <span class="token punctuation">.</span>o文件 <span class="token operator">-</span>I 头文件目录 <span class="token comment">// 例如：gcc -shared -o libtest.so *.o -I include</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="共享库使用"><a href="#共享库使用" class="headerlink" title="共享库使用"></a>共享库使用</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// -L 指定静态库的目录</span><span class="token comment">// -l 指定静态库目录中的哪个静态库，指定库时不能写前缀lib，也不能写后缀名.a</span><span class="token comment">// -I 指定头文件</span><span class="token comment">// -o 自定义生成可执行文件的名字</span>gcc main<span class="token punctuation">.</span>c <span class="token operator">-</span>I include <span class="token operator">-</span>L lib <span class="token operator">-</span>l mylib <span class="token operator">-</span>o build    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 使用了动态库的可执行文件运行时都要链接库，必须告知库的位置</span><span class="token comment"># 方法一：该方法是临时设置，设置LD_LIBRARY_PATH环境变量，程序运行时会查找LD_LIBRARY_PATH环境变量的值，能根据这个值来查找动态库</span><span class="token builtin class-name">echo</span> <span class="token variable">$LD_LIBRARY_PATH</span><span class="token builtin class-name">export</span> <span class="token assign-left variable">LD_LIBRARY_PATH</span><span class="token operator">=</span><span class="token variable">$LD_LIBRARY_PATH</span>:库的路径 <span class="token comment">#例如：export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/whn/mylib</span><span class="token comment"># 方法二：设置用户目录下的bashrc配置文件，在最后一行加入</span><span class="token builtin class-name">export</span> <span class="token assign-left variable">LD_LIBRARY_PATH</span><span class="token operator">=</span><span class="token variable">$LD_LIBRARY_PATH</span>:库的路径 <span class="token comment">#例如：export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/whn/mylib</span><span class="token comment"># 方法三：修改动态链接器的配置文件,将动态库的路径写到配置文件中</span><span class="token function">sudo</span> <span class="token function">vi</span> /etc/ld.so.conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h3 id="动态库优点"><a href="#动态库优点" class="headerlink" title="动态库优点"></a>动态库优点</h3><ul><li>执行程序的大小很小</li><li>动态库更新之后，如果函数接口没有改变，不需要重新编译文件</li></ul><h3 id="动态库缺点"><a href="#动态库缺点" class="headerlink" title="动态库缺点"></a>动态库缺点</h3><ul><li>执行程序时必须链接对应的库</li><li>加载速度没有静态库快</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 动态库 </tag>
            
            <tag> 静态库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法总结</title>
      <link href="2021/05/08/%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F/"/>
      <url>2021/05/08/%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><blockquote><p>采用<strong>顺序查找法</strong>查找插入位置</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// ptr第一个元素是哨兵不存放数据，num是包括哨兵在内总数</span><span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span><span class="token keyword">int</span> num<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>num<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>ptr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>ptr<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ptr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>ptr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>ptr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>ptr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                ptr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>ptr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            ptr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>ptr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>时间复杂度结论</strong></p></blockquote><ul><li>原始数据越接近有序，排序速度越快</li><li>最坏情况下（输入数据是逆有序的） Tw(n)=O(n<sup>2</sup>)</li><li>平均情况下，耗时差不多是最坏情况的一半 Te(n)=O(n<sup>2</sup>)</li><li>要提高查找次数<ul><li>减少元素的比较次数</li><li>减少元素的移动次数</li></ul></li></ul><hr><h3 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h3><blockquote><p>折半查找比顺序查找快，所以折半插入排序就平均性能来说比直接插入排序要快</p></blockquote><ul><li>时间复杂度为O(n<sup>2</sup>)</li><li>空间复杂度为O(1)</li><li>稳定的排序方法</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// ptr第一个元素是哨兵不存放数据，num是包括哨兵在内总数</span><span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>    <span class="token keyword">int</span> low<span class="token punctuation">,</span>high<span class="token punctuation">,</span>mid<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        ptr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>ptr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        low<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>        high<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>high<span class="token operator">>=</span>low<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            mid<span class="token operator">=</span><span class="token punctuation">(</span>low<span class="token operator">+</span>high<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>ptr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">></span>ptr<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span>                low<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                high<span class="token operator">=</span>mid<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">>=</span>high<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            ptr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>ptr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        ptr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>ptr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>它所需要的关键码比较次数与待排序对象序列的初始排序无关，仅依赖与对象个数。在插入第i个对象时，需要经过[log<sub>2</sub>i]+1次关键码比较，才能确定它应插入的位置；</p></blockquote><ul><li>当n较大时，总关键码比较次数比直接插入排序的最坏情况要好得多，当比其最好情况要差；</li><li>在对象的初始排序已经按关键码排好序或接近有序时，直接插入排序比折半插入排序执行的关键码比较次数要少；</li></ul><hr><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><ul><li>一次移动，移动位置较大，跳跃式地接近排序后的最终位置</li><li>最后一次只需要少量移动</li><li>增量序列必须是递减的，最后一个必须是1</li><li>增量序列应该是互质的</li></ul><blockquote><p>增量序列</p></blockquote><ol><li>定义增量序列D<sub>k</sub>: D<sub>M</sub>&gt;D<sub>M-1</sub>&gt;D<sub>M-2</sub>&gt;…&gt;D<sub>1</sub>=1</li><li>对每个D<sub>k</sub>进行“D<sub>k</sub>-间隔”插入排序</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> span<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>span<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        ptr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>ptr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>ptr<span class="token punctuation">[</span>i<span class="token operator">-</span>span<span class="token punctuation">]</span><span class="token operator">></span>ptr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span>i<span class="token operator">-</span>span<span class="token punctuation">;</span>j<span class="token operator">></span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>ptr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>ptr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>j<span class="token operator">=</span>j<span class="token operator">-</span>span<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                ptr<span class="token punctuation">[</span>j<span class="token operator">+</span>span<span class="token punctuation">]</span><span class="token operator">=</span>ptr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            ptr<span class="token punctuation">[</span>j<span class="token operator">+</span>span<span class="token punctuation">]</span><span class="token operator">=</span>ptr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">xiersort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">*</span>array<span class="token punctuation">,</span><span class="token keyword">int</span> arraysize<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arraysize<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">sort</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span>n<span class="token punctuation">,</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// 第一个元素为哨兵</span>    <span class="token keyword">int</span> ptr<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">39</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">71</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">36</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">31</span><span class="token punctuation">,</span><span class="token number">44</span><span class="token punctuation">,</span><span class="token number">32</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token number">17</span><span class="token punctuation">,</span><span class="token number">46</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// 增量序列</span>    <span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>ptr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">xiersort</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">,</span>array<span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span>ptr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>                <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>希尔排序算法效率与增量序列的取值有关</p></blockquote><ul><li>Hibbard增量序列<ul><li>D<sub>k</sub>=2<sup>k-1</sup>相邻元素互质，如15，7，3，1</li><li>最坏情况：T<sub>worst</sub>=O(n<sup>3/2</sup>)</li><li>猜想：T<sub>avg</sub>=O(n<sup>5/4</sup>)</li></ul></li><li>Sedgewick增量序列<ul><li>{1，5，19，41，109，…}</li><li>猜想：T<sub>avg</sub>=O(n<sup>7/6</sup>)   T<sub>worst</sub>=O(n<sup>4/3</sup>)</li></ul></li></ul><blockquote><p>希尔排序算法分析</p></blockquote><ul><li>时间复杂度是n和d的函数  O(n<sup>1.25</sup>)~O(1.6n<sup>1.25</sup>)  —— 经验公式</li><li>空间复杂度为O(1)</li><li>是一种不稳定的排序方法</li><li>最后一个增量值必须为1</li><li>不宜在链式存储结构上实现</li></ul><hr><h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 每躺结束时，不仅能挤出一个最大值到最后面位置，还能同时部分理顺其他元素 </span><span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">;</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">int</span> flag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 如果有其中的一趟中没有发生过交换就代表序列已经排好了，不需要进行后面的比较</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token operator">&amp;&amp;</span>flag<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        flag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token operator">-</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>ptr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span>ptr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                flag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>                x<span class="token operator">=</span>ptr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                ptr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>ptr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                ptr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>x<span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>冒泡排序总结</p></blockquote><ul><li>n个记录，总共需要n-1躺</li><li>第m躺需要比较n-m次</li><li>最好情况：正序；最坏情况：逆序</li></ul><blockquote><p>冒泡排序算法评价</p></blockquote><ul><li>冒泡排序最好时间复杂度是O(n)</li><li>冒泡排序最坏时间复杂度为O(n<sup>2</sup>)</li><li>冒泡排序平均时间复杂度为O(n<sup>2</sup>)</li><li>冒泡排序是稳定的</li></ul><hr><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><blockquote><p>基本思想：通过一趟排序，将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录进行排序，以达到整个序列有序</p><p>具体实现：选定一个中间数作为参考，所有元素与之比较，小的调到其左边，大的调到右边</p><p>中间数：可以是第一个数、最后一个数，最中间一个数</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// ptr[0]是哨兵</span><span class="token keyword">int</span> <span class="token function">psort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    ptr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>ptr<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token operator">&amp;&amp;</span>ptr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>ptr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">)</span>            high<span class="token operator">--</span><span class="token punctuation">;</span>        ptr<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token operator">=</span>ptr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token operator">&amp;&amp;</span>ptr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">></span>ptr<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">)</span>            low<span class="token operator">++</span><span class="token punctuation">;</span>        ptr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token operator">=</span>ptr<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    ptr<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token operator">=</span>ptr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> low<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> point<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        point<span class="token operator">=</span><span class="token function">psort</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span>low<span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span>low<span class="token punctuation">,</span>point<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span>point<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度<ul><li>可以证明，平均计算时间是O(nlog<sub>2</sub>n)<ul><li>sort() : O(log<sub>2</sub>n)</li><li>psort() : O(n)</li></ul></li><li>实验结果表明：就平均计算时间而言，快速排序是我们所讨论的所有内排序方法中最好的一个</li></ul></li><li>空间复杂度<ul><li>在平均情况下，需要O(logn)的栈空间</li><li>最坏情况下：栈空间可达O(n)</li></ul></li><li>快速排序是一种不稳定的排序方法</li><li>快速排序不适于对原本有序或基本有序的记录序列进行排序</li><li>划分元素的选取是影响时间性能的关键，输入数据次序越乱，锁选划分元素值的随机性越好，排序速度越快，快速排序不是自然排序方法，最坏情况下时间复杂度是O(n<sup>2</sup>)</li></ul><hr><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h3><blockquote><p>在待排序的数据中选出最大（小）的元素放在最终的位置</p></blockquote><ol><li>首先通过n-1次关键字比较，从n个记录中找出关键字最小的记录，将它与第一个记录交换</li><li>再通过n-2次比较，从剩余的n-1个记录中找出关键字次小的记录，将它与第二个记录交换</li><li>重复上述操作，共进行n-1趟排序后，排序结束</li></ol><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> min<span class="token punctuation">;</span>    <span class="token keyword">int</span> temp<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        min<span class="token operator">=</span>i<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>ptr<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token operator">></span>ptr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>                min<span class="token operator">=</span>j<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>min<span class="token operator">!=</span>i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            temp<span class="token operator">=</span>ptr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            ptr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>ptr<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">;</span>            ptr<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间复杂度<ul><li>记录移动次数<ul><li>最好情况：0</li><li>最坏情况：3(n-1)</li></ul></li><li>比较次数：无论待排序列处于什么状态，选择排序所需进行的比较次数相同</li></ul></li><li>算法稳定性<ul><li>简单选择排序是不稳定排序</li></ul></li></ul><hr><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><blockquote><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210421212805183.png" alt="image-20210421212805183" style="zoom:67%;"></blockquote><blockquote><p>从堆的定义可以看出，堆实质是满足如下性质的完全二叉树：二叉树中任一非叶子结点均小于（大于）它的孩子结点</p></blockquote><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210421213018266.png" alt="image-20210421213018266" style="zoom: 50%;"><blockquote><p>堆排序：若在输出堆顶的最小值（最大值）后，使得剩余n-1个元素的序列重又建成一个堆，则得到n个元素的次小值（次大值）……如此反复，便能得到一个有序序列，这个给过程称之为堆排序</p></blockquote><blockquote><p>实现堆排序需解决两个问题</p></blockquote><ol><li>如何由一个无序序列建成一个堆</li><li>如何在输出堆顶元素后，调整剩余元素为一个新的堆</li></ol><blockquote><p>如何在输出堆顶元素后，调整剩余元素为一个新的堆</p></blockquote><ol><li>输出堆顶元素之后，以堆中最后一个元素替代之；</li><li>然后将根结点值与左、右子树的根结点值进行比较，并与其中小者进行交换；</li><li>重复上述操作，直至叶子结点，将得到新的堆，称这个从堆顶至叶子的调整过程为“筛选”</li></ol><blockquote><p>如何由一个无序序列建成一个堆</p><p>只需依次将以序号为n/2，n/2-1，……，1的结点为根的子树均调整为堆即可</p><p>即：对应由n个元素组成的无序序列，“筛选”只需从第n/2个元素开始。</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">adjustheap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> root<span class="token punctuation">;</span>    root<span class="token operator">=</span>ptr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>left<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>right<span class="token punctuation">;</span>i<span class="token operator">=</span>i<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>right<span class="token operator">&amp;&amp;</span>ptr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>ptr<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">></span>ptr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        ptr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">=</span>ptr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        left<span class="token operator">=</span>i<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    ptr<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token operator">=</span>root<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// ptr[0]是哨兵不存储数据，n是除哨兵之外数据的个数</span><span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> temp<span class="token punctuation">;</span>    <span class="token comment">// 将无序序列按堆进行排序</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">adjustheap</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span>i<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>n<span class="token punctuation">;</span>i<span class="token operator">></span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        temp<span class="token operator">=</span>ptr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        ptr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>ptr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        ptr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">;</span>        <span class="token function">adjustheap</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>堆排序的时间主要耗费在建初始堆和调整堆新堆时进行的反复筛选上。堆排序在最坏情况下，其时间复杂度也为O(nlog<sub>2</sub>n)，这是堆排序的最大优点。无论待排序列中的记录时正序还是逆序排列，都不会使堆排序处于“最好”或“最坏”的状态</li><li>另外，堆排序仅需一个记录大小供交换用的辅助存储空间</li><li>然而堆排序是一种不稳定的排序方法，它不适用于待排序记录个数n较少的情况，但对于n较大的文件还是很有效的</li></ul><hr><h2 id="归并算法"><a href="#归并算法" class="headerlink" title="归并算法"></a>归并算法</h2><blockquote><p>整个归并排序仅需log<sub>2</sub>n趟</p></blockquote><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210422204050615.png" alt="image-20210422204050615" style="zoom:67%;"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> mid<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> t<span class="token operator">=</span>left<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>left<span class="token punctuation">,</span>j<span class="token operator">=</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>mid<span class="token operator">&amp;&amp;</span>j<span class="token operator">&lt;=</span>right<span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>ptr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>ptr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            data<span class="token punctuation">[</span>t<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>ptr<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>            data<span class="token punctuation">[</span>t<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>ptr<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>mid<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        data<span class="token punctuation">[</span>t<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>ptr<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>j<span class="token operator">&lt;=</span>right<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        data<span class="token punctuation">[</span>t<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>ptr<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span>left<span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>right<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        ptr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">mergesort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>right<span class="token operator">></span>left<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">int</span> mid<span class="token operator">=</span><span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token function">mergesort</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span>left<span class="token punctuation">,</span>mid<span class="token punctuation">,</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">mergesort</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span>mid<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">,</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">merge</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span>left<span class="token punctuation">,</span>mid<span class="token punctuation">,</span>right<span class="token punctuation">,</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>data<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>n<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">mergesort</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>归并排序算法排序</p></blockquote><ul><li>时间效率：O(nlog<sub>2</sub>n)</li><li>空间效率：O(n)</li><li>稳定性：稳定</li></ul><hr><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><blockquote><p>基数排序基本思想：分配+收集</p><p>设置若干个箱子，将关键字为k的记录放入第k个箱子，然后在按序号将非空的连接</p><p>基数排序：数字是有范围的，均由0-9这十个数字组成，则只需设置十个箱子，相继按个、十、百…进行排序</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> t<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    p<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">10</span><span class="token operator">*</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> key<span class="token punctuation">;</span>    <span class="token comment">// 支持十位数以内的排序</span>    <span class="token keyword">int</span> m<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> num<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> w<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> l<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> flag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            key<span class="token operator">=</span>ptr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">/</span>num<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>key<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                flag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            p<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">[</span>t<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span>ptr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            t<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">=</span>t<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            m<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        num<span class="token operator">=</span>num<span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>k<span class="token operator">&lt;</span>n<span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>t<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                l<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>t<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                ptr<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>p<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                t<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            w<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        l<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>时间效率：O(k*(n+m))<ul><li>k：关键字个数</li><li>m：关键字取值范围为m个值</li></ul></li><li>空间效率：O(n+m)</li><li>稳定性：稳定</li></ul><h2 id="排序总结"><a href="#排序总结" class="headerlink" title="排序总结"></a>排序总结</h2><blockquote><p>时间性能</p></blockquote><ul><li>时间复杂度为O(nlogn)的办法有：<ul><li>快速排序、堆排序和归并排序，其中以快速排序最好</li></ul></li><li>时间复杂度为O(n<sup>2</sup>)的有：<ul><li>直接插入排序、冒泡排序和简单选择排序，其中以直接插入为最好，特别是堆哪些堆关键字近似有序的记录序列尤为如此</li></ul></li><li>时间复杂度为O(n)的排序方法只有：基数排序</li></ul><ol><li>当待排记录序列按关键字顺序有序时，直接插入排序和冒泡排序能达到O(n)的时间复杂度；而对于快速排序而言，这是最不好的情况，此时的时间性能退化为O(n<sup>2</sup>)，因此时应该尽量避免的情况</li><li>简单选择排序、堆排序和归并排序的时间性能不随记录序列中关键字的分布而改变</li></ol><blockquote><p>空间性能</p></blockquote><ol><li>所有的简单排序方法（包括：直接插入、冒泡和简单选择）和堆排序的空间复杂度为O(1)</li><li>快速排序为O(logn)，为栈所需的辅助空间</li><li>归并排序所需辅助空间最多，其空间复杂度为O(n)</li><li>链式基数排序徐附设队列首尾指针，则空间复杂度为O(rd)</li></ol><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210422223305649.png" alt="image-20210422223305649"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux扩容根分区（非lvm）</title>
      <link href="2021/05/08/Linux%E6%89%A9%E5%AE%B9%E6%A0%B9%E5%88%86%E5%8C%BA%E9%9D%9Elvm/"/>
      <url>2021/05/08/Linux%E6%89%A9%E5%AE%B9%E6%A0%B9%E5%88%86%E5%8C%BA%E9%9D%9Elvm/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux扩容根分区（非lvm）"><a href="#Linux扩容根分区（非lvm）" class="headerlink" title="Linux扩容根分区（非lvm）"></a>Linux扩容根分区（非lvm）</h1><blockquote><p>查看自己的磁盘空间分配lsblk，当前sda磁盘有8G空间，但是sda2分区只有5G，可以将剩下的空间分配给sda2</p></blockquote><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210418110343907.png" alt="image-20210418110343907" style="zoom: 80%;"><ol><li><p>编辑分区：fdisk /dev/sda</p><ol><li>查看帮助：m</li><li>删除分区sda2分区：d 回车 2 回车（千万不能保存否则就真的会被删除）</li><li>新建sda2分区：<ol><li>输入：n 回车</li><li>新建分区类型输入：p 回车（p表示主分区）</li><li>选择分区：2 回车</li><li>起止扇区不输入任何内容，直接回车默认，将硬盘上剩余所有容量分给sda2</li></ol></li><li>保存退出：w 回车</li></ol></li><li><p>扩容文件系统</p><ol><li>xfs_growfs /dev/sda2    （适用于centos系统且是xfs文件系统）</li><li>resize2fs /dev/sda2    （适用于Ubuntu系统且是ext4文件系统）</li></ol><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210418111551793.png" alt="image-20210418111551793"></p></li></ol><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210418111626338.png" alt="image-20210418111626338"></p><p>来源于：<a href="https://www.jianshu.com/p/9db2df60fd0a">虚拟机 Centos7（非LVM）扩容根目录</a></p><p><a href="https://www.it610.com/article/1291694723261603840.htm">Ubuntu根目录扩容，亲测有效，简单易用</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议</title>
      <link href="2021/05/08/http%E5%8D%8F%E8%AE%AE/"/>
      <url>2021/05/08/http%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><h2 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h2><ul><li>请求行<ul><li>请求方法：GET、POST、HEAD、OPTIONS、TRACE 等等<ul><li>HEAD：比如我们只是确认一个内容是否正常存在，不需要返回照片内容，这时候用HEAD比较合适</li><li>TRACE：是你用了代理上网，比如用代理访问new.163.com，你想看看代理有没有修改你的HTTP请求。可以用TRACE来测试一些，163.com的服务器就会把最后收到的请求返回给你</li><li>这些请求方法虽然HTTP协议里规定的，但WEB SERVER未必允许或支持这些方法，OPTIONS是返回服务器可用的请求方法</li></ul></li><li>请求路径（即请求的相对路径）</li><li>请求协议：HTTP/1.1、HTTP/1.0 等等</li></ul></li><li>请求头信息<ul><li>HOST（必须）</li><li>Cookie（模拟登录）</li><li>Content-Type（POST必须）</li><li>Content-Length（POST必须）</li><li>Referer（代表网页的来源，即上一页的地址，如果直接在浏览器上输入网址进来，则没有Referer信息，这也是为什么服务器我们的图片是从哪里引用的，也知道我们的客户从哪个网站链接点击过来的）</li><li>Others</li></ul></li><li>请求主体信息（POST必须）<ul><li>JSON</li><li>XML</li></ul></li></ul><blockquote><p>注意：请求头与请求主体之间必须要有一个空行隔开</p><p>GET和POST请求最常用</p></blockquote><hr><blockquote><p>请求行与请求头信息：GET实例</p></blockquote><pre class="line-numbers language-php+HTML" data-language="php+HTML"><code class="language-php+HTML">GET &#x2F; HTTP&#x2F;1.1HOST:localhostcsrftoken:......<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><hr><blockquote><p>请求行与请求头信息：POST实例</p></blockquote><pre class="line-numbers language-php+HTML" data-language="php+HTML"><code class="language-php+HTML">POST &#x2F; HTTP&#x2F;1.1HOST:localhostcsrftoken:......Content-Length:20Content-Type:application&#x2F;x-www-form-urlencoded<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h2><ul><li>响应行<ul><li>协议版本</li><li>状态码<ul><li>1XX：接受到请求，继续处理</li><li>2XX：请求成功</li><li>3XX：请求重定向<ul><li>302：请求被临时重定向到另一个地址</li><li>304：Not Modifiled（资源未修改，从本地取缓存）</li><li>301：请求被永久重定向到另一个地址</li><li>307：重定向中保持原有的post数据，防止数据丢失</li></ul></li><li>4XX：客户端请求错误<ul><li>404：没有找到请求文件</li><li>403：客户端访问错误</li></ul></li><li>5XX：服务端出现问题<ul><li>503：服务器暂时不可用</li><li>500：服务器内部错误</li></ul></li></ul></li><li>状态文字：对于状态码的文字解释</li></ul></li><li>响应头信息</li><li>响应主体信息<ul><li>文本</li><li>二进制文件</li></ul></li></ul><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210626221021040.png" alt="image-20210626221021040"></p><h2 id="当输入网址回车会发生什么"><a href="#当输入网址回车会发生什么" class="headerlink" title="当输入网址回车会发生什么"></a>当输入网址回车会发生什么</h2><p>输入一个网址并按回车的时候浏览器会根据输入的URL去查找对应的IP，具体过程如下：</p><p>（1）首先是查找浏览器缓存，浏览器会保存一段时间内访问过的一些网址的DNS信息，不同浏览器保存的时常不等。</p><p>（2）如果没有找到对应的记录，这个时候浏览器会尝试调用操作系统缓存来继续查找这个网址的对应DNS信息。</p><p>（3）如果还是没找到对应的IP，那么接着会发送一个请求到路由器上，然后路由器在自己的路由器缓存上查找记录，路由器一般也存有DNS信息。</p><p>（4）如果还是没有，这个请求就会被发送到ISP（注：Internet Service Provider，互联网服务提供商，就是网络运营商，中国电信中国移动等），ISP也会有相应的ISP DNS服务器，就是本地DNS服务器，请求的域名基本上都能在这里找得到。</p><p>（5）如果还是没有的话， ISP的DNS服务器会将请求发向根域名服务器进行搜索。根域名服务器就是面向全球的顶级DNS服务器，共有13台逻辑上的服务器，从A到M命名，真正的实体服务器则有几百台，分布于全球各大洲。</p><p>（6）如果到了这里还是找不到域名的对应信息，那只能说明一个问题：这个域名本来就不存在，它没有在网上正式注册过。或者域名过期了。</p><p>浏览器终于得到了IP以后，向服务器发送TCP连接，TCP连接经过三次握手。</p><p>浏览器和服务器建立连接以后，浏览器接着给这个IP地址给服务器发送一个http请求，方式为get，例如访问<a href="http://www.baidu.com.其本质是在建立起的tcp连接中,按照http协议标准发送一个索要网页的请求./">www.baidu.com。其本质是在建立起的TCP连接中，按照HTTP协议标准发送一个索要网页的请求。</a></p><p>这个get请求包含了主机（Host）、用户代理(User-Agent)，用户代理就是自己的浏览器，它是你的”代理人”，Connection（连接属性）中的keep-alive表示浏览器告诉对方服务器在传输完现在请求的内容后不要断开连接，不断开的话下次继续连接速度就很快了。可能还会有Cookies，Cookies保存了用户的登陆信息，一般保存的是用户的JSESSIONID，在每次向服务器发送请求的时候会重复发送给服务器。</p><p>在建立连接发送请求时每个服务端需要和客户端保持通信，有很多客户端都会和服务器进行通信。服务器为了识别是哪个客户端与它通信，就必须用一个标识记录客户端的信息。客户端首次访问服务器，服务端返回响应时通过附带一个记录的客户端信息的标识来返回给客户端，这个标识就是JSESSIONID，JSESSIONID就放在了客户端的Cookies里。当客户端再次向服务器发送请求时上就使用上次记录的Cookies里面的JSESSIONID，这样服务器就知道是哪个浏览器了。这样他们之间就能保持通信了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> http </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux进程间通信-System V IPC</title>
      <link href="2021/05/08/system-V-IPC/"/>
      <url>2021/05/08/system-V-IPC/</url>
      
        <content type="html"><![CDATA[<h2 id="System-V-IPC概述"><a href="#System-V-IPC概述" class="headerlink" title="System V IPC概述"></a>System V IPC概述</h2><blockquote><p>System V引入了三种高级进程间的通信进制：消息队列、共享内存、信号量</p><p>IPC对象(消息队列、共享内存和信号量)存在于内核中而不是文件系统中，由用户控制释放，不像管道的释放由内核控制</p><p>IPC对象通过其标识符来引用和访问，所有IPC对象在内核空间有唯一性标志ID，在用户空间的唯一性标识符称为key</p></blockquote><hr><blockquote><p>System V IPC 对象访问</p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># IPC对象是全局对象，可用ipcs查看</span><span class="token comment"># 只显示消息队列</span>$ ipcs -q <span class="token comment"># 只显示信号量</span>$ ipcs -s<span class="token comment"># 只显示共享内存</span>$ ipcs -m <span class="token comment"># 其他的参数</span>$ ipcs -help<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><blockquote><p>System V IPC 函数头文件</p></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;sys&#x2F;types.h&gt; &#x2F;&#x2F;公共头文件，声明了key_t类型#include &lt;sys&#x2F;ipc.h&gt;   &#x2F;&#x2F;公共头文件#include &lt;sys&#x2F;msg.h&gt;   &#x2F;&#x2F;消息队列函数的头文件#include &lt;sys&#x2F;sem.h&gt;   &#x2F;&#x2F;信号量函数的头文件#include &lt;sys&#x2F;shm.h&gt;   &#x2F;&#x2F;共享内存函数的头文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><blockquote><p>ftok()函数</p></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; Unix系统中有个重要的概念叫做：万物皆文件。在很多IPC机制中的操作都是针对文件描述符（简称 fd）的，然而System V却不同，它没有对fd进行操作，而是针对 IPC对象的id来操作的，而这个id（标识符）又是通过key（键）来生成的。&#x2F;&#x2F; 三种IPC有各自的函数来生成id，但是它们所利用的key却都由函数ftok()生成，看一下函数声明：#include &lt;sys&#x2F;types.h&gt;#include &lt;sys&#x2F;ipc.h&gt;key_t ftok(const char *pathname, int proj_id);&#x2F;&#x2F; 参数pathname是文件路径名（该文件必须存在，通常用当前路径名  “.”）；proj_id被称作子id，自己指定一个整型。 注意如果两个进程要通过System V的IPC通信，那么它们的ftok函数的两个参数必须相同，这样才能生成同样的key，从而产出同样的id。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>返回值类型key_t在&lt;sys/types.h&gt;中被定义，实际是一个整型（32位），该key是路径名和子id共同作用的结果。这里要用到该文件路径的stat结构。（系统中每一个文件都有其对应的stat结构）</p></blockquote><ul><li>key的31~24位为ftok函数第二个参数<strong>proj_id</strong>的低8位</li><li>key的23~16位为该文件stat结构中<strong>st_dev</strong>属性的低8位</li><li>key的15~0位为该文件stat结构中<strong>st_ino</strong>属性的低16位</li></ul><blockquote><p>ipc_perm结构体</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 三种IPC机制都有对应的结构体，这些结构体中有一个 共同的成员就是这个ipc_perm，用来标识IPC对象的权限</span><span class="token keyword">struct</span> <span class="token class-name">ipc_perm</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">key_t</span>          __key<span class="token punctuation">;</span> <span class="token comment">/* key */</span>    <span class="token class-name">uid_t</span>          uid<span class="token punctuation">;</span>   <span class="token comment">/* 所有者的有效用户ID */</span>    <span class="token class-name">gid_t</span>          gid<span class="token punctuation">;</span>   <span class="token comment">/* 所有者的有效组ID */</span>    <span class="token class-name">uid_t</span>          cuid<span class="token punctuation">;</span>  <span class="token comment">/* 创造者的有效用户ID */</span>    <span class="token class-name">gid_t</span>          cgid<span class="token punctuation">;</span>  <span class="token comment">/* 创造者的有效组ID */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> mode<span class="token punctuation">;</span>  <span class="token comment">/* 权限 */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> __seq<span class="token punctuation">;</span> <span class="token comment">/* 可忽略 */</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><blockquote><p>IPC对象函数</p></blockquote><table><thead><tr><th align="center">分类</th><th align="center">创建函数</th><th align="center">控制函数</th><th align="center">独立函数</th></tr></thead><tbody><tr><td align="center">消息队列</td><td align="center">msgget</td><td align="center">msgctl</td><td align="center">msgsnd，msgrcv</td></tr><tr><td align="center">信号量</td><td align="center">semget</td><td align="center">semctl</td><td align="center">semop</td></tr><tr><td align="center">共享内存</td><td align="center">shmget</td><td align="center">shmctl</td><td align="center">shmat、shmdt</td></tr></tbody></table><hr><ul><li>创建函数（get函数）创建的是IPC对象的标识符（id），它们以ftok生成的键（key）为参数（以及其他参数）生成。</li><li>控制函数（ctl函数）控制的是对应<strong>IPC数据结构</strong>的成员属性，从而改变IPC对象的状态。</li></ul><blockquote><p>实际上key和id都能唯一地标识一个IPC对象，但是之所以没有直接对key操作，而是拐弯对id进行操作，是因为id除了能唯一标识IPC对象之外，还包含其他信息（比如权限）。因此通过get函数生成的id，可以类比 文件描述符（fd），而get函数在功能上来说可以类比 open函数。</p><p>只能说IPC的id可以类比文件描述符fd，实际上它并不是fd的一种。不信你可以写个程序创建一个消息队列，然后进入死循环，去/proc/进程id/fd/目录下面看看有没有这个id值。fd是进程相关的，进程终止之后fd被释放，而IPC对象在进程结束之前如果没有显示的删除，那么及时进程结束了，它还独立存在。</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">msgget</span><span class="token punctuation">(</span><span class="token class-name">key_t</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">semget</span><span class="token punctuation">(</span><span class="token class-name">key_t</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> nsems<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">shmget</span><span class="token punctuation">(</span><span class="token class-name">key_t</span> key<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token keyword">int</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>这个函数都有一个flag参数（由逻辑或组成），该参数也可类比open函数的flag参数，虽然取值不尽相同。这三个函数的flag取值是一样的</p><p>通常的用法是 <strong>IPC_CREAT|IPC_EXCL</strong> ，如果不存在key则创建它，如果已存在则返回失败（EEXIST）</p></blockquote><hr><blockquote><p>Linux中有三个命令是和System V的三个IPC相关的</p></blockquote><ul><li>ipcmk</li><li>ipcrm</li><li>ipcs</li></ul><blockquote><p>其中ipcmk命令用于创建IPC对象，来看一下它的三个主要选项：</p></blockquote><table><thead><tr><th align="center">选项</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">-Q</td><td align="center">创建一个消息队列</td></tr><tr><td align="center">-S</td><td align="center">创建信号量，后跟一参数指明数量</td></tr><tr><td align="center">-M</td><td align="center">创建共享内存，后跟一参数指明大小</td></tr></tbody></table><hr><blockquote><p>可知创建消息队列的时候选项后面是没有参数的，而创建信号量和共享内存的时候选项后面还有一参数（用于指明数量或大小）。正好信号量和共享内存的get函数也比消息队列多一个</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// CTL函数</span><span class="token keyword">int</span> <span class="token function">msgctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> msqid<span class="token punctuation">,</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">msqid_ds</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">semctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> semid<span class="token punctuation">,</span> <span class="token keyword">int</span> semnum<span class="token punctuation">,</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//有三参数和四参数两种，根据cmd的不同而不同</span><span class="token keyword">int</span> <span class="token function">shmctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> shmid<span class="token punctuation">,</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">shmid_ds</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><blockquote><p>三个ctl控制函数其实是在操作三种IPC机制对应的三种数据结构：</p><p>此处要注意的是消息队列的对应的结构体名称，其前缀为msq而非msg（这个缩写有点违和，取了队列的首字母q）</p></blockquote><ul><li>msqid_ds</li><li>semid_ds</li><li>shmid_ds</li></ul><blockquote><p> 这些结构体中有一个<strong>共同的成员</strong>就是前面提到的 <strong>ipc_perm</strong>。</p></blockquote><hr><blockquote><p>这三个函数都有一个cmd参数（控制参数），不同的IPC机制它们的控制参数是不一样的。但是由几个控制参数是公共的（定义在ipc.h中）。下面以消息队列为例（也适用于信号量和共享内存）</p></blockquote><table><thead><tr><th align="center">cmd</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">IPC_SET</td><td align="center">设置消息队列的属性。按照buf指向的结构中的值，来设置此IPC对象</td></tr><tr><td align="center">IPC_STAT</td><td align="center">读取消息队列的属性。取得此队列的msqid_ds结构，并存放在buf中</td></tr><tr><td align="center">IPC_INFO</td><td align="center">（只有Linux有）返回系统级的限制，结果放在buf中</td></tr><tr><td align="center">IPC_RMID</td><td align="center">删除消息队列。只能由其创建者或超级用户（root）来删除</td></tr></tbody></table><hr><p>来源于：<a href="https://blog.csdn.net/qq_38211852/article/details/80475818">System V IPC概述</a></p><h2 id="System-V-共享内存"><a href="#System-V-共享内存" class="headerlink" title="System V 共享内存"></a>System V 共享内存</h2><blockquote><p><strong>shmget函数</strong></p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/ipc.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/shm.h></span></span><span class="token keyword">int</span> <span class="token function">shmget</span><span class="token punctuation">(</span><span class="token class-name">key_t</span> key<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token keyword">int</span> shmflg<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol><li>key 通过 ftok 获取</li><li>size 以字节为单位指定内存区大小</li><li>shmflg 表示权限组合 可以是 <code>IPC_EXCL | IPC_CREAT | 0600</code></li><li>调用成功后，该共享内存区会被以size的大小初始化为0，并返回一个shmid让我们操作该共享内存区</li></ol><hr><blockquote><p><strong>shmat函数</strong></p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 该函数可以将打开的共享内存区将其映射到调用进程的地址空间</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/shm.h></span></span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">shmat</span><span class="token punctuation">(</span><span class="token keyword">int</span> shmid<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>shmaddr<span class="token punctuation">,</span> <span class="token keyword">int</span> shmflg<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol><li>shmid 由 shmget返回</li><li>shmaddr是一个非空指针返回值取决于shmflg（如果指定NULL，则由系统选择）</li><li>shmflg如果指定了SHM_RND，则相应的共享内存区附接到由shmaddr参数指定的地址</li></ol><hr><blockquote><p><strong>shmdt函数</strong></p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 调用这个函数进程可以主动切断这个内存区，不过如果没有调用该函数，当进程结束时会自动切断。切断连接后，共享内存区依然存在</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/shm.h></span></span><span class="token keyword">int</span> <span class="token function">shmdt</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>shmaddr<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><hr><blockquote><p><strong>shmctl函数</strong></p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 该函数完成对共享内存区的各种操作</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/ipc.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/shm.h></span></span><span class="token keyword">int</span> <span class="token function">shmctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> shmid<span class="token punctuation">,</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">shmid_ds</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//其中</span><span class="token keyword">struct</span> <span class="token class-name">shmid_ds</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">ipc_perm</span> shm_perm<span class="token punctuation">;</span>    <span class="token comment">/* 对应该共享内存的ipc_perm结构 */</span>    <span class="token class-name">size_t</span>          shm_segsz<span class="token punctuation">;</span>   <span class="token comment">/* 以字节表示的共享内存区域的大小 */</span>    <span class="token class-name">time_t</span>          shm_atime<span class="token punctuation">;</span>   <span class="token comment">/* 最近一次附加操作的时间 */</span>    <span class="token class-name">time_t</span>          shm_dtime<span class="token punctuation">;</span>   <span class="token comment">/* 最近一次分离操作的时间 */</span>    <span class="token class-name">time_t</span>          shm_ctime<span class="token punctuation">;</span>   <span class="token comment">/* 最近一次改变的时间 */</span>    <span class="token class-name">pid_t</span>           shm_cpid<span class="token punctuation">;</span>    <span class="token comment">/* 创建该共享内存的进程ID */</span>    <span class="token class-name">pid_t</span>           shm_lpid<span class="token punctuation">;</span>    <span class="token comment">/* 最近一次调用shmop函数的进程ID */</span>    <span class="token class-name">shmatt_t</span>        shm_nattch<span class="token punctuation">;</span>  <span class="token comment">/* 当前使用该共享内存区域的进程数 */</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">ipc_perm</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">key_t</span>          _key<span class="token punctuation">;</span>    <span class="token comment">/* 对象的键 */</span>    <span class="token class-name">uid_t</span>          uid<span class="token punctuation">;</span>      <span class="token comment">/* 所有者的有效用户ID */</span>    <span class="token class-name">gid_t</span>          gid<span class="token punctuation">;</span>      <span class="token comment">/* 所有者的有效组ID */</span>    <span class="token class-name">uid_t</span>          cuid<span class="token punctuation">;</span>     <span class="token comment">/* 创建者的有效用户ID */</span>    <span class="token class-name">gid_t</span>          cgid<span class="token punctuation">;</span>     <span class="token comment">/* 创建者的有效组ID */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> mode<span class="token punctuation">;</span>     <span class="token comment">/* 表示改对象的访问权限 */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> __seq<span class="token punctuation">;</span>    <span class="token comment">/* 对象的应用序号 */</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>该函数的命令</p></blockquote><ul><li>IPC_RMID：删除</li><li>IPC_SET：设置</li><li>IPC_STAT：获取</li><li>SHM_LOCK：将共享内存区域上锁</li><li>SHM_UNLOCK：将上锁的共享内存区域释放</li></ul><hr><blockquote><p><strong>共享内存区的限制</strong></p></blockquote><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 共享内存区最大字节数</span>$ <span class="token function">cat</span> /proc/sys/kernel/shmmax<span class="token comment"># 最多共享内存区数</span>$ <span class="token function">cat</span> /proc/sys/kernel/shmall<span class="token comment"># 最大共享内存区标识符数</span>$ <span class="token function">cat</span> /proc/sys/kernel/shmmni<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><blockquote><p><strong>实例</strong></p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 头文件</span><span class="token comment">// shm.h</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/mman.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span>        <span class="token comment">/* For mode constants */</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fcntl.h></span>           <span class="token comment">/* For O_* constants */</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;semaphore.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;time.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;assert.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;errno.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/ipc.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/shm.h></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//shmwrite.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"shm.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PATHNAME</span> <span class="token string">"."</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span>      id<span class="token punctuation">;</span>    <span class="token keyword">int</span> flag<span class="token punctuation">;</span>    <span class="token keyword">char</span>    <span class="token operator">*</span>ptr<span class="token punctuation">;</span>    <span class="token class-name">size_t</span>  length<span class="token operator">=</span><span class="token number">1024</span><span class="token punctuation">;</span>    <span class="token class-name">key_t</span> key<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">shmid_ds</span> buff<span class="token punctuation">;</span>    key <span class="token operator">=</span> <span class="token function">ftok</span><span class="token punctuation">(</span>PATHNAME<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>key<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ftok error\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    id <span class="token operator">=</span> <span class="token function">shmget</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> length<span class="token punctuation">,</span>IPC_CREAT <span class="token operator">|</span> IPC_EXCL<span class="token operator">|</span> S_IRUSR <span class="token operator">|</span> S_IWUSR  <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>id<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"errno: %s\r\n"</span><span class="token punctuation">,</span><span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"shmget error\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    ptr <span class="token operator">=</span> <span class="token function">shmat</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>ptr<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"shmat error\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">shmctl</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span>IPC_STAT<span class="token punctuation">,</span><span class="token operator">&amp;</span>buff<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>buff<span class="token punctuation">.</span>shm_segsz<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token operator">*</span>ptr<span class="token operator">++</span> <span class="token operator">=</span> i<span class="token operator">%</span><span class="token number">256</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"shm.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> <span class="token keyword">const</span> pathname<span class="token operator">=</span><span class="token string">"."</span><span class="token punctuation">;</span>    <span class="token keyword">int</span>      id<span class="token punctuation">;</span>    <span class="token keyword">int</span> flag<span class="token punctuation">;</span>    <span class="token keyword">char</span>    <span class="token operator">*</span>ptr<span class="token punctuation">;</span>    <span class="token class-name">size_t</span>  length<span class="token operator">=</span><span class="token number">1024</span><span class="token punctuation">;</span>    <span class="token class-name">key_t</span> key<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">shmid_ds</span> buff<span class="token punctuation">;</span>    key <span class="token operator">=</span> <span class="token function">ftok</span><span class="token punctuation">(</span>pathname<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>key<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ftok error\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    flag <span class="token operator">=</span> IPC_CREAT <span class="token operator">|</span>  <span class="token number">0400</span><span class="token punctuation">;</span>    id <span class="token operator">=</span> <span class="token function">shmget</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> length<span class="token punctuation">,</span> flag<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>id<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"shmget error\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    ptr <span class="token operator">=</span> <span class="token function">shmat</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>ptr<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"shmat error\r\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">shmctl</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span>IPC_STAT<span class="token punctuation">,</span><span class="token operator">&amp;</span>buff<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> c<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>buff<span class="token punctuation">.</span>shm_segsz<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        c<span class="token operator">=</span><span class="token operator">*</span>ptr<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"ptr[%d]=%d\r\n"</span><span class="token punctuation">,</span>i<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">shmctl</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> IPC_RMID<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><h2 id="System-V-消息队列"><a href="#System-V-消息队列" class="headerlink" title="System V 消息队列"></a>System V 消息队列</h2><blockquote><p><strong>概述</strong>：消息队列可以认为是一个消息链表，System V 消息队列使用消息队列标识符标识。具有足够特权的任何进程都可以往一个队列放置一个消息，具有足够特权的任何进程都可以从一个给定队列读出一个消息。在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达。System V 消息队列是随内核持续的，只有在内核重起或者显示删除一个消息队列时，该消息队列才会真正被删除。可以将内核中的某个特定的消息队列画为一个消息链表</p></blockquote><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210418175625310.png" alt="image-20210418175625310" style="zoom:80%;"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 对于系统中每个消息队列，内核维护一个msqid_ds的信息结构</span><span class="token keyword">struct</span> <span class="token class-name">msqid_ds</span>  <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">msqid_ds</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">ipc_perm</span> msg_perm<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">msg</span> <span class="token operator">*</span>msg_first<span class="token punctuation">;</span>      <span class="token comment">/* 队列中的第一条信息，未使用 */</span>    <span class="token keyword">struct</span> <span class="token class-name">msg</span> <span class="token operator">*</span>msg_last<span class="token punctuation">;</span>       <span class="token comment">/* 队列中的最后一条信息，未使用 */</span>    __kernel_time_t msg_stime<span class="token punctuation">;</span>  <span class="token comment">/* 上次msgsnd时间 */</span>    __kernel_time_t msg_rtime<span class="token punctuation">;</span>  <span class="token comment">/* 上次msgrcv时间 */</span>    __kernel_time_t msg_ctime<span class="token punctuation">;</span>  <span class="token comment">/* 最后更改时间 */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>  msg_lcbytes<span class="token punctuation">;</span> <span class="token comment">/* Reuse junk fields for 32 bit */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span>  msg_lqbytes<span class="token punctuation">;</span> <span class="token comment">/* ditto */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> msg_cbytes<span class="token punctuation">;</span>  <span class="token comment">/* 队列上的当前字节数 */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> msg_qnum<span class="token punctuation">;</span>    <span class="token comment">/* 队列中的消息数 */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> msg_qbytes<span class="token punctuation">;</span>  <span class="token comment">/* 队列中的最大字节数 */</span>    __kernel_ipc_pid_t msg_lspid<span class="token punctuation">;</span>   <span class="token comment">/* 最后一个msgsnd的pid */</span>    __kernel_ipc_pid_t msg_lrpid<span class="token punctuation">;</span>   <span class="token comment">/* 最后收到的pid */</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/ipc.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/msg.h></span></span><span class="token comment">// 调用返回：成功返回消息队列描述字，否则返回-1</span><span class="token keyword">int</span> <span class="token function">msgget</span><span class="token punctuation">(</span><span class="token class-name">key_t</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> msgflg<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>参数key是一个键值，由ftok获得；msgflg参数是一些标志位。该调用返回与健值key相对应的消息队列描述字。</p><p>在以下两种情况下，该调用将创建一个新的消息队列：</p></blockquote><ul><li>如果没有消息队列与键值key相对应，并且msgflg中包含了IPC_CREAT标志位；</li><li>key参数为IPC_PRIVATE，参数key设置成常数IPC_PRIVATE并不意味着其他进程不能访问该消息队列，只意味着即将创建新的消息队列；</li></ul><blockquote><p>参数msgflg可以为以下：IPC_CREAT、IPC_EXCL、IPC_NOWAIT或三者的或结果</p></blockquote><hr><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 该系统调用从msgid代表的消息队列中读取一个消息，并把消息存储在msgp指向的msgbuf结构中</span><span class="token comment">// msqid为消息队列描述字；消息返回后存储在msgp指向的地址，msgsz指定msgbuf的mtext成员的长度（即消息内容的长度），msgtyp为请求读取的消息类型；</span><span class="token class-name">ssize_t</span> <span class="token function">msgrcv</span><span class="token punctuation">(</span><span class="token keyword">int</span> msqid<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>msgp<span class="token punctuation">,</span> <span class="token class-name">size_t</span> msgsz<span class="token punctuation">,</span> <span class="token keyword">long</span> msgtyp<span class="token punctuation">,</span><span class="token keyword">int</span> msgflg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// msgp是一个结构指针（即是该消息队列内部一个节点的结构），其结构一般为</span><span class="token keyword">struct</span> <span class="token class-name">msgbuf</span><span class="token punctuation">&#123;</span><span class="token keyword">long</span> mtype<span class="token punctuation">;</span><span class="token keyword">char</span> mtext<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">//其中元素个数可为任意值但是小于256；</span><span class="token punctuation">&#125;</span>；<span class="token comment">// 调用返回：成功返回0，否则返回-1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>msgtyp为请求读取的消息类型；读消息标志msgflg可以为以下几个常值的或：</p></blockquote><ul><li>IPC_NOWAIT 如果没有满足条件的消息，调用立即返回，此时，errno=ENOMSG</li><li>IPC_EXCEPT 与msgtyp&gt;0配合使用，返回队列中第一个类型不为msgtyp的消息</li><li>IPC_NOERROR 如果队列中满足条件的消息内容大于所请求的msgsz字节，则把该消息截断，截断部分将丢失</li></ul><blockquote><p>msgrcv()解除阻塞的条件有三个：</p></blockquote><ol><li>消息队列中有了满足条件的消息；</li><li>msqid代表的消息队列被删除；</li><li>调用msgrcv（）的进程被信号中断;</li></ol><hr><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 向msgid代表的消息队列发送一个消息，即将发送的消息存储在msgp指向的msgbuf结构中，消息的大小由msgze指定</span><span class="token keyword">int</span> <span class="token function">msgsnd</span><span class="token punctuation">(</span><span class="token keyword">int</span> msqid<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>msgp<span class="token punctuation">,</span> <span class="token class-name">size_t</span> msgsz<span class="token punctuation">,</span> <span class="token keyword">int</span> msgflg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// msgp是一个结构指针（即是该消息队列内部一个节点的结构），其结构一般为</span><span class="token keyword">struct</span> <span class="token class-name">msgbuf</span><span class="token punctuation">&#123;</span><span class="token keyword">long</span> mtype<span class="token punctuation">;</span><span class="token keyword">char</span> mtext<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">//其中元素个数可为任意值但是小于256；</span><span class="token punctuation">&#125;</span>；<span class="token comment">// 调用返回：成功返回0，否则返回-1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>对发送消息来说，有意义的msgflg标志为IPC_NOWAIT，指明在消息队列没有足够空间容纳要发送的消息时，msgsnd是否等待。造成msgsnd()等待的条件有两种：</p></blockquote><ul><li>当前消息的大小与当前消息队列中的字节数之和超过了消息队列的总容量</li><li>当前消息队列的消息数（单位”个”）不小于消息队列的总容量（单位”字节数”），此时，虽然消息队列中的消息数目很多，但基本上都只有一个字节</li></ul><blockquote><p>msgsnd()解除阻塞的条件有三个：</p></blockquote><ol><li>不满足上述两个条件，即消息队列中有容纳该消息的空间；</li><li>msqid代表的消息队列被删除；</li><li>调用msgsnd（）的进程被信号中断；</li></ol><hr><hr><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">msgctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> msqid<span class="token punctuation">,</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">msqid_ds</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 调用返回：成功返回0，否则返回-1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>该系统调用对由msqid标识的消息队列执行cmd操作，共有三种cmd操作：IPC_STAT、IPC_SET 、IPC_RMID</p></blockquote><ol><li>IPC_STAT：该命令用来获取消息队列信息，返回的信息存贮在buf指向的msqid结构中；</li><li>IPC_SET：该命令用来设置消息队列的属性，要设置的属性存储在buf指向的msqid结构中；可设置属性包括：msg_perm.uid、msg_perm.gid、msg_perm.mode以及msg_qbytes，同时，也影响msg_ctime成员；</li><li>IPC_RMID：删除msqid标识的消息队列；</li></ol><blockquote><p><strong>实例</strong></p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// server.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/msg.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/ipc.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ID</span> <span class="token expression"><span class="token number">1</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXTEXT</span> <span class="token expression"><span class="token number">64</span></span></span><span class="token keyword">struct</span> <span class="token class-name">mybuf</span><span class="token punctuation">&#123;</span>    <span class="token keyword">long</span> mtype<span class="token punctuation">;</span>    <span class="token keyword">char</span> mtext<span class="token punctuation">[</span>MAXTEXT<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">key_t</span> key<span class="token punctuation">;</span>    <span class="token keyword">int</span> id<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">mybuf</span> data<span class="token punctuation">;</span>    key<span class="token operator">=</span><span class="token function">ftok</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">,</span>ID<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>key<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"ftok error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>id<span class="token operator">=</span><span class="token function">msgget</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>IPC_CREAT<span class="token operator">|</span><span class="token number">0644</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"msgget error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    data<span class="token punctuation">.</span>mtype<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">strncpy</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>mtext<span class="token punctuation">,</span><span class="token string">"type 1"</span><span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span><span class="token string">"type 1"</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">msgsnd</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span><span class="token operator">&amp;</span>data<span class="token punctuation">,</span>MAXTEXT<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"msgsnd error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    data<span class="token punctuation">.</span>mtype<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>    <span class="token function">strncpy</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>mtext<span class="token punctuation">,</span><span class="token string">"type 2"</span><span class="token punctuation">,</span><span class="token function">strlen</span><span class="token punctuation">(</span><span class="token string">"type 2"</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">msgsnd</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span><span class="token operator">&amp;</span>data<span class="token punctuation">,</span>MAXTEXT<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"msgsnd error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// cilent</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span>          </span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span>         </span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string.h></span>         </span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span>         </span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/ipc.h></span>        </span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/msg.h></span>        </span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAXTEXT</span> <span class="token expression"><span class="token number">64</span>         </span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ID</span> <span class="token expression"><span class="token number">1</span>               </span></span><span class="token keyword">struct</span> <span class="token class-name">mybuf</span><span class="token punctuation">&#123;</span>                  <span class="token keyword">long</span> mtype<span class="token punctuation">;</span>                <span class="token keyword">char</span> mtext<span class="token punctuation">[</span>MAXTEXT<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>                         <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                                      <span class="token punctuation">&#123;</span>                                                   <span class="token keyword">struct</span> <span class="token class-name">mybuf</span> rec<span class="token punctuation">;</span>                               <span class="token class-name">key_t</span> key<span class="token punctuation">;</span>                                      <span class="token keyword">int</span> id<span class="token punctuation">;</span>                                         key<span class="token operator">=</span><span class="token function">ftok</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">,</span>ID<span class="token punctuation">)</span><span class="token punctuation">;</span>                               <span class="token keyword">if</span><span class="token punctuation">(</span>key<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                                        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"ftok error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                           <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                    <span class="token punctuation">&#125;</span>                                               <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>id<span class="token operator">=</span><span class="token function">msgget</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>IPC_EXEC<span class="token operator">|</span><span class="token number">0644</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                      <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"msgget error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                    <span class="token punctuation">&#125;</span>                                               <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">msgrcv</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span><span class="token operator">&amp;</span>rec<span class="token punctuation">,</span>MAXTEXT<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>              <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"msgrcv error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                    <span class="token punctuation">&#125;</span>                                               <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span>rec<span class="token punctuation">.</span>mtext<span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>                                   <span class="token punctuation">&#125;</span>                                               <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>server运行后</p></blockquote><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210418203323877.png" alt="image-20210418203323877"></p><blockquote><p>cilent运行后</p></blockquote><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210418203459841.png" alt="image-20210418203459841"></p><hr><h2 id="System-V-信号量"><a href="#System-V-信号量" class="headerlink" title="System V 信号量"></a>System V 信号量</h2><blockquote><p><strong>semget</strong>函数</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/ipc.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/sem.h></span></span><span class="token keyword">int</span> <span class="token function">semget</span><span class="token punctuation">(</span><span class="token class-name">key_t</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> nsems<span class="token punctuation">,</span> <span class="token keyword">int</span> semflg<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>第一个参数key通过ftok根据特定path获取</li><li>第二个参数表示信号量集里面的信号量的个数</li><li>第三个参数标志位比如：semflg=O_CREAT|O_EXCL|0644</li></ul><blockquote><p>semget调用成功之后，会在内核维护一个信号结构</p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">semid_ds</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">struct</span> <span class="token class-name">ipc_perm</span> sem_perm<span class="token punctuation">;</span>  <span class="token comment">//例如0644，0600，也有一些宏特别指定，不过还是数字好记</span>    <span class="token class-name">time_t</span>          sem_otime<span class="token punctuation">;</span>     <span class="token class-name">time_t</span>          sem_ctime<span class="token punctuation">;</span>     <span class="token keyword">unsigned</span> <span class="token keyword">long</span>   sem_nsems<span class="token punctuation">;</span>     <span class="token keyword">struct</span> <span class="token class-name">sem</span> <span class="token operator">*</span> sem_base<span class="token punctuation">;</span><span class="token comment">//这一项在man page中没有明确表示</span><span class="token punctuation">&#125;</span>   <span class="token comment">//但man page提到信号量集中有这样的结构</span><span class="token keyword">struct</span> <span class="token class-name">sem</span><span class="token punctuation">&#123;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span>  semval<span class="token punctuation">;</span>   <span class="token comment">/* 信号量的值 */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span>  semzcnt<span class="token punctuation">;</span>  <span class="token comment">/* # waiting for zero */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span>  semncnt<span class="token punctuation">;</span>  <span class="token comment">/* # waiting for increase */</span>    <span class="token class-name">pid_t</span>           sempid<span class="token punctuation">;</span>   <span class="token comment">/* ID of process that did last op */</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210420160351727.png" alt="image-20210420160351727" style="zoom: 80%;"><blockquote><p><strong>semop函数</strong></p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 使用semget打开一个信号量后，可以对其中一个或多个信号量操作使用semop函数来执行</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/ipc.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/sem.h></span></span><span class="token keyword">struct</span> <span class="token class-name">sembuf</span><span class="token punctuation">&#123;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span> sem_num<span class="token punctuation">;</span>  <span class="token comment">/* 指定特定信号量的操作 */</span>    <span class="token keyword">short</span>          sem_op<span class="token punctuation">;</span>   <span class="token comment">/* 信号量的操作 */</span>    <span class="token keyword">short</span>          sem_flg<span class="token punctuation">;</span>  <span class="token comment">/* 操作标志 */</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">semop</span><span class="token punctuation">(</span><span class="token keyword">int</span> semid<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sembuf</span> <span class="token operator">*</span>sops<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> nsops<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// sem_num指定特定信号量的操作</span><span class="token comment">// semop函数通过命令执行了信号量操作</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>sem_op &gt; 0；将值添加到semval上，对应与释放某个资源</li><li>sem_op = 0；希望等待到semval值变为0，如果已经是0，则立即返回，否则semzcnt+1，并线程阻塞</li><li>sem_op &lt; 0；希望等待到semval值变为大于或等于|sem_op||sem_op|。这对应分配资源。如果已经满足条件，则semval减去sem_op的绝对值，否则semncnt+1并且线程投入睡眠</li></ul><hr><blockquote><p><strong>semctl函数</strong></p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/ipc.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/sem.h></span></span><span class="token comment">// 第四个参数</span><span class="token keyword">union</span> semun <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span>              val<span class="token punctuation">;</span>    <span class="token comment">/* Value for SETVAL */</span>    <span class="token keyword">struct</span> <span class="token class-name">semid_ds</span> <span class="token operator">*</span>buf<span class="token punctuation">;</span>    <span class="token comment">/* Buffer for IPC_STAT, IPC_SET */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span>  <span class="token operator">*</span>array<span class="token punctuation">;</span>  <span class="token comment">/* Array for GETALL, SETALL */</span>    <span class="token keyword">struct</span> <span class="token class-name">seminfo</span>  <span class="token operator">*</span>__buf<span class="token punctuation">;</span>  <span class="token comment">/* Buffer for IPC_INFO (Linux-specific) */</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token comment">// semnum指定信号量集中的某个成员，类似于数组下标（0,1,2…直到nsems-1）</span><span class="token keyword">int</span> <span class="token function">semctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> semid<span class="token punctuation">,</span> <span class="token keyword">int</span> semnum<span class="token punctuation">,</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">GETVAL</td><td align="center">返回semval</td></tr><tr><td align="center">SETVAL</td><td align="center">把semval设定为指定值</td></tr><tr><td align="center">GETPID</td><td align="center">返回sempid</td></tr><tr><td align="center">GETNCNT</td><td align="center">返回semncnt</td></tr><tr><td align="center">GETZCNT</td><td align="center">返回semzcnt</td></tr><tr><td align="center">GETALL</td><td align="center">返回所有semval值，由array指针返回</td></tr><tr><td align="center">SETALL</td><td align="center">设置所有semval</td></tr><tr><td align="center">IPC_RMID</td><td align="center">删除指定id信号量集</td></tr><tr><td align="center">IPC_SET</td><td align="center">设置uid，gid和mode</td></tr><tr><td align="center">IPC_STAT</td><td align="center">返回semid_ds结构</td></tr></tbody></table><blockquote><p><strong>实例</strong></p></blockquote><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// semsend.c，实现不断的通过共享内存的方式发送1 2 3 4 5</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/ipc.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/shm.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/sem.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DATA</span> <span class="token expression"><span class="token number">0</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SPACE</span> <span class="token expression"><span class="token number">1</span></span></span><span class="token keyword">union</span> semun <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span>              val<span class="token punctuation">;</span>    <span class="token comment">/* Value for SETVAL */</span>    <span class="token keyword">struct</span> <span class="token class-name">semid_ds</span> <span class="token operator">*</span>buf<span class="token punctuation">;</span>    <span class="token comment">/* Buffer for IPC_STAT, IPC_SET */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span>  <span class="token operator">*</span>array<span class="token punctuation">;</span>  <span class="token comment">/* Array for GETALL, SETALL */</span>    <span class="token keyword">struct</span> <span class="token class-name">seminfo</span>  <span class="token operator">*</span>__buf<span class="token punctuation">;</span>  <span class="token comment">/* Buffer for IPC_INFO                                (Linux-specific) */</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">key_t</span> shmkey<span class="token punctuation">,</span>semkey<span class="token punctuation">;</span>    <span class="token keyword">int</span> shmid<span class="token punctuation">,</span>semid<span class="token punctuation">;</span>    <span class="token keyword">union</span> semun semctla<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>ptr<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    shmkey<span class="token operator">=</span><span class="token function">ftok</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>shmkey<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"shm ftok error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    shmid<span class="token operator">=</span><span class="token function">shmget</span><span class="token punctuation">(</span>shmkey<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>IPC_EXCL<span class="token operator">|</span>IPC_CREAT<span class="token operator">|</span><span class="token number">0644</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>shmid<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        shmid<span class="token operator">=</span><span class="token function">shmget</span><span class="token punctuation">(</span>shmkey<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0644</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    ptr<span class="token operator">=</span><span class="token function">shmat</span><span class="token punctuation">(</span>shmid<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>ptr<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"shmat error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    semkey<span class="token operator">=</span><span class="token function">ftok</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>semkey<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"sem ftok error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    semid<span class="token operator">=</span><span class="token function">semget</span><span class="token punctuation">(</span>semkey<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>IPC_EXCL<span class="token operator">|</span>IPC_CREAT<span class="token operator">|</span><span class="token number">0644</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>semid<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        semid<span class="token operator">=</span><span class="token function">semget</span><span class="token punctuation">(</span>semkey<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0644</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        semctla<span class="token punctuation">.</span>val<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">semctl</span><span class="token punctuation">(</span>semid<span class="token punctuation">,</span>DATA<span class="token punctuation">,</span>SETVAL<span class="token punctuation">,</span>semctla<span class="token punctuation">)</span><span class="token punctuation">;</span>        semctla<span class="token punctuation">.</span>val<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token function">semctl</span><span class="token punctuation">(</span>semid<span class="token punctuation">,</span>SPACE<span class="token punctuation">,</span>SETVAL<span class="token punctuation">,</span>semctla<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token string">"12345"</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">sembuf</span> sem<span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        sem<span class="token punctuation">.</span>sem_num<span class="token operator">=</span>SPACE<span class="token punctuation">;</span>        sem<span class="token punctuation">.</span>sem_op<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        sem<span class="token punctuation">.</span>sem_flg<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">semop</span><span class="token punctuation">(</span>semid<span class="token punctuation">,</span><span class="token operator">&amp;</span>sem<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token operator">*</span>ptr<span class="token operator">=</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        i<span class="token operator">=</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">;</span>        sem<span class="token punctuation">.</span>sem_num<span class="token operator">=</span>DATA<span class="token punctuation">;</span>        sem<span class="token punctuation">.</span>sem_op<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>        sem<span class="token punctuation">.</span>sem_flg<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">semop</span><span class="token punctuation">(</span>semid<span class="token punctuation">,</span><span class="token operator">&amp;</span>sem<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>                                                                                                                            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// semrev.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unistd.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/ipc.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/shm.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/sem.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DATA</span> <span class="token expression"><span class="token number">0</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SPACE</span> <span class="token expression"><span class="token number">1</span></span></span><span class="token keyword">union</span> semun <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span>              val<span class="token punctuation">;</span>    <span class="token comment">/* Value for SETVAL */</span>    <span class="token keyword">struct</span> <span class="token class-name">semid_ds</span> <span class="token operator">*</span>buf<span class="token punctuation">;</span>    <span class="token comment">/* Buffer for IPC_STAT, IPC_SET */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">short</span>  <span class="token operator">*</span>array<span class="token punctuation">;</span>  <span class="token comment">/* Array for GETALL, SETALL */</span>    <span class="token keyword">struct</span> <span class="token class-name">seminfo</span>  <span class="token operator">*</span>__buf<span class="token punctuation">;</span>  <span class="token comment">/* Buffer for IPC_INFO                                (Linux-specific) */</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">key_t</span> shmkey<span class="token punctuation">,</span>semkey<span class="token punctuation">;</span>    <span class="token keyword">int</span> shmid<span class="token punctuation">,</span>semid<span class="token punctuation">;</span>    <span class="token keyword">union</span> semun semctla<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>ptr<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>    shmkey<span class="token operator">=</span><span class="token function">ftok</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>shmkey<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"shm ftok error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    shmid<span class="token operator">=</span><span class="token function">shmget</span><span class="token punctuation">(</span>shmkey<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span>IPC_EXCL<span class="token operator">|</span>IPC_CREAT<span class="token operator">|</span><span class="token number">0644</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>shmid<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        shmid<span class="token operator">=</span><span class="token function">shmget</span><span class="token punctuation">(</span>shmkey<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0644</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    ptr<span class="token operator">=</span><span class="token function">shmat</span><span class="token punctuation">(</span>shmid<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>ptr<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"shmat error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    semkey<span class="token operator">=</span><span class="token function">ftok</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>semkey<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"sem ftok error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    semid<span class="token operator">=</span><span class="token function">semget</span><span class="token punctuation">(</span>semkey<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span>IPC_EXCL<span class="token operator">|</span>IPC_CREAT<span class="token operator">|</span><span class="token number">0644</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>semid<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        semid<span class="token operator">=</span><span class="token function">semget</span><span class="token punctuation">(</span>semkey<span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0644</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token keyword">else</span><span class="token punctuation">&#123;</span>        semctla<span class="token punctuation">.</span>val<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">semctl</span><span class="token punctuation">(</span>semid<span class="token punctuation">,</span>DATA<span class="token punctuation">,</span>SETVAL<span class="token punctuation">,</span>semctla<span class="token punctuation">)</span><span class="token punctuation">;</span>                                                                                         semctla<span class="token punctuation">.</span>val<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token function">semctl</span><span class="token punctuation">(</span>semid<span class="token punctuation">,</span>SPACE<span class="token punctuation">,</span>SETVAL<span class="token punctuation">,</span>semctla<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">struct</span> <span class="token class-name">sembuf</span> sem<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        sem<span class="token punctuation">.</span>sem_num<span class="token operator">=</span>DATA<span class="token punctuation">;</span>        sem<span class="token punctuation">.</span>sem_op<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        sem<span class="token punctuation">.</span>sem_flg<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">semop</span><span class="token punctuation">(</span>semid<span class="token punctuation">,</span><span class="token operator">&amp;</span>sem<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">write</span><span class="token punctuation">(</span>STDOUT_FILENO<span class="token punctuation">,</span>ptr<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">usleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sem<span class="token punctuation">.</span>sem_num<span class="token operator">=</span>SPACE<span class="token punctuation">;</span>        sem<span class="token punctuation">.</span>sem_op<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>        sem<span class="token punctuation">.</span>sem_flg<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token function">semop</span><span class="token punctuation">(</span>semid<span class="token punctuation">,</span><span class="token operator">&amp;</span>sem<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210420172509023.png" alt="image-20210420172509023"></p>]]></content>
      
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> Linux进程通信 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建博客</title>
      <link href="2021/05/07/Blog_building/"/>
      <url>2021/05/07/Blog_building/</url>
      
        <content type="html"><![CDATA[<h2 id="node-js"><a href="#node-js" class="headerlink" title="node.js"></a>node.js</h2><p><a href="https://nodejs.org/en/">node.js下载地址</a></p><p>安装完成之后，打开cmd，用node -v 和 npm -v 查看安装是否成功以及版本</p><p><strong>设置npm在安装全局模块时的路径和环境变量</strong></p><p>默认情况下安装模块的时候会装在C盘，占用C盘的空间，还有可能导致hexo无法使用，需要设置npm</p><p>在nodejs的安装位置创建两个文件夹<strong>node_cache</strong> 和 <strong>node_global</strong></p><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210507215534810.png" alt="image-20210507215534810"></p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm config set prefix &quot;G:\Program Files\nodejs\node_global&quot;npm config set cache &quot;G:\Program Files\nodejs\node_cache&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>在<strong>系统变量</strong>中新建一个变量为“NODE_PATH”，值为G:\Program Files\nodejs\modules</p><p>然后编辑<strong>用户变量</strong>里的Path，将相应npm的路径<strong>修改</strong>为：G:\Program Files\nodejs\node_global</p><p>在 <strong>cmd</strong> 命令下执行 npm install webpack -g </p><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>安装Hexo，首先在任意盘建立一个工作文件夹，点开工作文件夹，鼠标右键打开 Git Bush Here，输入npm命令安装Hexo：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install -g hexo-cli<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在该工作目录下初始化博客：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hexo init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在该工作目录下静态部署：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">hexo g <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这时网页已经部署完成，输入 hexo s 命令可以查看</p><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210507220552801.png" alt="image-20210507220552801"></p><p>浏览器输入 <a href="https://link.zhihu.com/?target=http://baixin.io/2015/08/HEXO%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E6%9C%80%E5%8E%9F%E5%A7%8B%E7%9A%84%E6%95%88%E6%9E%9C%E4%BA%86">http://localhost:4000</a> 就可以打开新部署的网页</p><h2 id="将Hexo部署在GitHub上"><a href="#将Hexo部署在GitHub上" class="headerlink" title="将Hexo部署在GitHub上"></a>将Hexo部署在GitHub上</h2><h3 id="GitHub新建仓库"><a href="#GitHub新建仓库" class="headerlink" title="GitHub新建仓库"></a>GitHub新建仓库</h3><p><strong>仓库名称</strong>必须是“<strong>用户名.github.io</strong>”，例如D-light-D.github.io，将仓库创建为公共</p><h3 id="修改-config-yml"><a href="#修改-config-yml" class="headerlink" title="修改_config.yml"></a>修改_config.yml</h3><p>回到工作目录下，打开 _config.yml，进入最后一行，添加以下内容</p><p><strong>注意</strong>：branch，如果仓库的<strong>默认分支</strong>是<strong>master</strong>则为<strong>master</strong>，如果是main则填main，以此类推</p><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210507221546004.png" alt="image-20210507221546004"></p><p>repo 来自于：</p><p><img src="https://gitee.com/cabbage-is-white-and-white/picture/raw/master/image-20210507221632256.png" alt="image-20210507221632256"></p><p>然后回到 Blog 文件夹中，打开 Git Bash，安装<strong>Git部署插件</strong>，输入命令：</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">npm install hexo-deployer-git --save<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后执行：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">hexo clean   #清除缓存文件 db.json 和已生成的静态文件 publichexo g       #生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)hexo d       #自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>完成以后，打开浏览器，输入 <a href="https://link.zhihu.com/?target=https://fengye97.github.io/">https://xxx.github.io</a> 就可以打开你的网页了，例如我的就是：<a href="https://d-light-d.github.io/">https://d-light-d.github.io</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/05/07/hello-world/"/>
      <url>2021/05/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
